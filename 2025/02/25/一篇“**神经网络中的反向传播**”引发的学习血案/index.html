<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>AI自动化爬虫项目对比报告 - A-Acorner 信息的一角</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="A-Acorner 信息的一角"><meta name="msapplication-TileImage" content="/img/一角favicon.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="A-Acorner 信息的一角"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="AI自动化爬虫项目对比报告"><meta property="og:type" content="blog"><meta property="og:title" content="AI自动化爬虫项目对比报告"><meta property="og:url" content="http://acorner.ac.cn/2025/02/25/%E4%B8%80%E7%AF%87%E2%80%9C**%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD**%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A1%80%E6%A1%88/"><meta property="og:site_name" content="A-Acorner 信息的一角"><meta property="og:description" content="AI自动化爬虫项目对比报告"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://acorner.ac.cn/img/og_image.png"><meta property="article:published_time" content="2025-02-25T03:20:54.429Z"><meta property="article:modified_time" content="2025-02-25T03:21:11.065Z"><meta property="article:author" content="ViniJack.SJX"><meta property="article:tag" content="AI"><meta property="article:tag" content="爬虫"><meta property="article:tag" content="框架"><meta property="article:tag" content="自动化"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://acorner.ac.cn/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://acorner.ac.cn/2025/02/25/%E4%B8%80%E7%AF%87%E2%80%9C**%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD**%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A1%80%E6%A1%88/"},"headline":"AI自动化爬虫项目对比报告","image":["http://acorner.ac.cn/img/og_image.png"],"datePublished":"2025-02-25T03:20:54.429Z","dateModified":"2025-02-25T03:21:11.065Z","author":{"@type":"Person","name":"ViniJack.SJX"},"publisher":{"@type":"Organization","name":"A-Acorner 信息的一角","logo":{"@type":"ImageObject","url":"http://acorner.ac.cn/img/一角logo.png"}},"description":"AI自动化爬虫项目对比报告"}</script><link rel="canonical" href="http://acorner.ac.cn/2025/02/25/%E4%B8%80%E7%AF%87%E2%80%9C**%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD**%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A1%80%E6%A1%88/"><link rel="icon" href="/img/%E4%B8%80%E8%A7%92favicon.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link data-pjax rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/%E4%B8%80%E8%A7%92logo.png" alt="A-Acorner 信息的一角" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/A-Corner/a-corner.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-25T03:20:54.429Z" title="2025/2/25 11:20:54">2025-02-25</time>发表</span><span class="level-item"><time dateTime="2025-02-25T03:21:11.065Z" title="2025/2/25 11:21:11">2025-02-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/AI/">AI</a><span> / </span><a class="link-muted" href="/categories/%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/">分析报告</a></span><span class="level-item">3 小时读完 (大约23102个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">AI自动化爬虫项目对比报告</h1><div class="content"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近不停的听到反向传播以及方向传播的优化方法的一些东西，久好奇翻了一番之前的看过的一篇文章</p>
<p>原文url:<a target="_blank" rel="noopener" href="https://serokell.io/blog/understanding-backpropagation">https://serokell.io/blog/understanding-backpropagation</a></p>
<p>还是先放上译文：</p>
<p>好的，以下是文章内容的中文翻译：<br>​<br><strong>神经网络中的反向传播</strong><br>​<br><strong>作者：</strong> Irena Logunova<br>​<br><strong>发布日期：</strong> 2023 年 12 月 19 日<br>​<br><strong>阅读时长：</strong> 13 分钟<br>​<br>反向传播是神经网络深度学习的一个基本组成部分。自 21 世纪初以来，它的发展极大地促进了深度学习算法的广泛采用。在这篇文章中，我们将探讨这种方法的基本概念、应用和历史。<br>​<br><strong>什么是前向传播和反向传播？</strong><br>​<br>神经网络中的前向传播是指输入数据通过网络各层进行计算并产生输出的过程。每一层处理数据并将其传递到下一层，直到获得最终输出。在此过程中，网络学习识别数据中的模式和关系，通过反向传播调整其权重，以最小化预测输出和实际输出之间的差异。<br>​<br>（图片：前向传播和反向传播示意图）<br>​<br>反向传播过程包括计算预测输出和实际目标输出之间的误差，同时将信息反向传递到前馈网络中，从最后一层开始，一直到第一层。为了计算特定层的梯度，使用微积分的链式法则将所有后续层的梯度组合起来。<br>​<br>反向传播，也称为误差的反向传播，是一种广泛用于计算深度前馈神经网络中导数的技术。它在用于训练此类网络的各种监督学习算法中起着至关重要的作用。<br>​<br>神经网络的训练涉及使用梯度下降，这是一种迭代优化算法，用于发现可微函数的局部最小值。在训练过程中，计算损失函数来衡量网络预测与实际值之间的差异。反向传播能够计算损失函数相对于网络中每个权重的梯度。这种能力支持单独的权重更新，在多次训练迭代中逐步减少损失函数。<br>​<br><strong>反向传播过程是什么样的？</strong><br>​<br>反向传播的目的是通过微调神经网络的权重和偏置来最小化成本函数。这些调整的程度取决于成本函数相对于这些特定参数的梯度。通过链式法则计算梯度，反向传播有效地将误差信息向后传播到网络中。因此，网络可以沿梯度的相反方向迭代更新其参数。这个迭代过程使神经网络能够收敛到改进的性能和准确的预测。<br>​<br>神经网络中反向传播计算权重的梯度的基本步骤是前向传播和反向传播。<br>​<br><strong>前向传播</strong><br>​<br>在前向传播过程中，输入数据逐层通过网络传播，从输入层开始，一直到输出层。网络中的每个神经元接收输入，计算输入的加权和，应用激活函数，并将输出传递到下一层。这个过程一直持续到获得最终输出。前向传播根据当前权重计算网络的输出。<br>​<br>在我们进行反向传播之前，我们需要介绍计算最佳权重的最快方法，这对于复杂的多参数网络来说并非易事。这就是计算图发挥作用的地方。<br>​<br><strong>什么是计算图？</strong><br>​<br>计算图是一种有向图，用于表示模型内部执行的计算。该图通常以数据 (X) 和标签 (Y) 等输入开始。当我们从左到右移动图形时，会遇到表示计算函数所涉及的基本计算的节点。例如，存在用于输入 (X) 和权重矩阵 (W) 之间的矩阵乘法的节点、用于合页损失（用于 SVM 分类器）的红色节点以及用于模型中正则化项的绿色节点。该图以表示要在模型训练期间计算的标量损失 (L) 的输出节点结束。虽然这个计算图对于由于操作数量有限的线性模型来说似乎很简单，但对于具有多次计算的复杂模型来说，它变得更加复杂和关键。<br>​<br>（图片：深度网络示意图）<br>​<br>当我们向后移动时，为了计算最佳损失函数，计算图是一种实现最佳解决方案的方法，它可以显著减少所需的计算量。<br>​<br>这个过程在[这篇白皮书](this whitepaper)中有详细解释。<br>​<br>在每个节点上，反向模式微分会合并源自该节点的所有路径。我们不需要评估权重相互影响的所有可能组合，但由于有导数，我们可以通过仅计算每个节点的反向操作一次来获得正确的系数。<br>​<br><strong>反向传播</strong><br>​<br>在反向传播中，通过将误差反向传播到网络中来计算权重的梯度。它从输出层开始，一直到输入层。通过将网络的预测输出与真实输出或目标值进行比较来量化误差。使用微积分的链式法则计算损失函数相对于每个权重的梯度，这涉及计算每个层权重的偏导数。然后使用梯度来更新网络的权重，旨在最小化损失函数。<br>​<br>反向传播本质上决定了每个权重对总体误差的贡献程度，并相应地调整它们。通过迭代执行前向和反向传播，网络学习调整其权重，提高其做出准确预测的能力。<br>​<br>观看此视频，了解前向和反向传播的详细说明。<br>​<br>（视频：Backpropagation, step-by-step | DL3）<br>​<br><strong>反向传播算法有哪些类型？</strong><br>​<br>反向传播网络的两种主要类型是静态反向传播（提供即时映射）和循环反向传播（涉及定点学习）。<br>​  </p>
<ol>
<li><strong>静态反向传播：</strong> 它通常用于前馈神经网络和一些卷积神经网络 (CNN)，其中数据点之间没有时间依赖性。该算法累积一批数据点的损失函数梯度，然后对模型的参数执行一次更新。批处理过程有助于利用现代硬件中的并行处理能力，从而使大型数据集的训练过程更加高效。<br>​<br>    该算法能够解决静态分类问题，例如光学字符识别 (OCR)。  </li>
<li><strong>循环反向传播：</strong> 循环反向传播是用于循环神经网络 (RNN) 的反向传播算法的扩展。在 RNN 中，数据通过一系列相互连接的节点循环流动，从而使网络能够保留来自先前时间步的信息。<br>​<br>    循环反向传播涉及及时传播 RNN 中的误差信号。它计算损失函数相对于模型参数在多个时间步长的梯度，同时考虑到当前时间步长和先前时间步长之间的依赖关系和相互作用。此过程使网络能够学习和更新其参数，以提高其在需要顺序或时间依赖性的任务（例如自然语言处理、语音识别和时间序列预测）中的性能。<br>​<br><strong>为什么要使用反向传播？</strong><br>​<br>在前向传播完成后，将评估网络的误差，理想情况下应将其最小化。<br>​<br>如果当前误差很大，则表明网络尚未有效地从数据中学习。换句话说，当前的权重集不足以准确地最小化误差并生成精确的预测。因此，有必要更新神经网络权重以减少误差。<br>​<br>反向传播算法在权重更新中起着至关重要的作用，其目标是最小化误差。<br>​<br><strong>反向传播算法的优点</strong><br>​<br>反向传播具有以下几个关键优势：<br>​  </li>
<li><strong>内存效率</strong><br>​<br>    与遗传算法等替代优化算法相比，它可以有效地计算导数，从而减少内存使用量。这在处理大型神经网络时特别有用。  </li>
<li><strong>速度</strong><br>​<br>    它速度很快，特别是对于中小型神经网络。然而，随着层数和神经元数量的增加，计算更多导数会导致性能变慢。  </li>
<li><strong>通用性</strong><br>​<br>    该算法适用于各种网络架构，包括卷积神经网络、生成对抗网络、全连接网络等。反向传播的通用性使其能够在各种场景中有效发挥作用。  </li>
<li><strong>参数简单性</strong><br>​<br>    反向传播不需要调整特定参数，从而减少了开销。该过程中涉及的唯一参数与梯度下降算法相关，例如学习率。<br>​<br>在使用神经网络时，可以利用不同的算法来减少损失函数的输出和学习率，以提供更精确的结果。有许多替代方法可以修改神经网络的属性，例如 Adam（自适应矩估计），多年来一直是最新技术，Nesterov 加速梯度，AdaGrad 和 AdaDelta。<br>​<br>如果您想了解更多信息，请查看[不同优化器的详细说明](check out this detailed description)。<br>​<br>损失函数优化的最先进算法之一是 [Sophia 优化器](Sophia optimizer)，由斯坦福大学研究人员于 2023 年 5 月发布。此类优化器的经典示例是成本函数，我们将在下面解释。<br>​<br><strong>计算反向传播：成本函数</strong><br>​<br>成本函数表示模型输出与所需输出之间差异的平方。<br>​<br>当将神经网络应用于具有相关像素值的数百万张图像时，我们可以假设预测输出和相应的实际值。<br>​<br>较小的成本函数表示模型在训练数据上的性能更好。此外，预计具有最小化成本函数的模型在未见过的数据上也表现良好。<br>​<br>成本函数接受所有输入（可能涉及数百万个参数），并产生一个值。该值作为指南，指示模型中需要多少改进。它通知模型其性能不佳，并且需要调整其权重和偏置。然而，仅仅告知模型其性能是不够的。我们还需要为模型提供一种使其能够最小化误差的方法。<br>​<br>这就是梯度下降和反向传播发挥作用的地方，它们提供了模型更新其参数和减少成本函数的方法。<br>​<br><strong>梯度下降</strong><br>​<br>为了实现更好的参数调整并最小化实际输出和训练输出之间的差异，我们采用了一种称为梯度下降的直观算法。目前，梯度下降是机器学习和深度学习中最流行的优化策略。该算法识别错误并有效地减少它们。<br>​<br>从数学上讲，它通过找到最小点来优化[凸函数](convex function)。<br>​<br>梯度的概念可以理解为衡量函数的输出在其输入略微修改时的变化程度。它也可以可视化为函数的斜率，其中较高的梯度表示更陡的斜率并有助于模型更快地学习。从比喻上讲，您可以将其比作下降到山谷的底部而不是爬上山顶。这是因为它是一种最小化给定函数的优化算法。<br>​<br><strong>梯度下降的类型</strong><br>​<br>现在让我们探讨不同类型的梯度下降。<br>​<br>（图片：梯度下降类型图）<br>​<br><strong>批量梯度下降</strong><br>​<br>批量大小是指单个批次中包含的训练示例的总数。由于无法一次性将整个数据集传递到神经网络，因此数据集被分成多个批次或子集。<br>​<br>在批量梯度下降中，使用完整数据集来计算成本函数的梯度。然而，这种方法可能很慢，因为它需要为每次更新计算整个数据集的梯度。这可能具有挑战性，尤其是在大型数据集的情况下。成本函数是在初始化参数后计算的，并且该过程涉及从磁盘读取所有记录到内存中。在每次迭代之后，采取一个步骤，然后重复该过程。<br>​<br><strong>小批量梯度下降</strong><br>​<br>小批量梯度下降是一种常用的算法，可提供更快、更准确的结果。数据集被分成小组或“n”个训练示例的批次。与批量梯度下降不同，小批量梯度下降不使用整个数据集。在每次迭代中，采用“n”个训练示例的子集来计算成本函数的梯度。这种方法减少了参数更新的方差，从而实现更稳定的收敛。此外，它可以利用优化的[矩阵运算](matrix operations)，从而提高梯度计算的效率。<br>​<br><strong>随机梯度下降</strong><br>​<br>随机梯度下降 (SGD) 根据在每次迭代时为数据的随机子集计算的梯度来更新模型的参数，从而允许更快的计算。在每次训练迭代（或时期）中，从训练数据集中选择一批随机数据点。然后使用所选批次计算损失函数相对于模型参数的梯度。接下来，根据计算出的梯度更新模型的参数。在梯度的相反方向上执行更新，以朝着损失函数的最小值移动。对固定数量的迭代或直到满足收敛标准重复这些步骤。<br>​<br><strong>Tensorflow 和 Pytorch 中的反向传播</strong><br>​<br>反向传播算法是用于训练深度学习模型的关键技术。<br>​<br>在 <strong>TensorFlow</strong> 中，您可以通过定义神经网络模型、使用优化器和损失函数编译它、准备数据，然后使用 fit 函数训练模型来使用反向传播。TensorFlow 的自动微分处理训练期间梯度的计算，从而更容易地应用反向传播来有效地训练复杂模型。<br>​<br>要在 <strong>PyTorch</strong> 中使用反向传播，您需要定义神经网络架构和损失函数。在训练过程中，数据通过网络前向传递以进行预测，然后在通过网络各层反向计算梯度的过程中使用反向函数自动计算梯度。然后使用这些梯度通过优化算法（如随机梯度下降）更新模型的参数。<br>​<br>要了解有关在 PyTorch 中使用反向传播的更多信息，请观看本教程：<br>​<br>（视频：PyTorch Tutorial 04 - Backpropagation - Theory With Example）<br>​<br><strong>反向传播的应用</strong><br>​<br>反向传播广泛用于训练各种类型的神经网络，并且在最近深度学习的普及中发挥了重要作用。但是反向传播的应用范围更广，从天气预报到分析数值稳定性。以下是其在机器学习中的几个应用示例。<br>​<br><strong>人脸识别</strong><br>​<br>卷积神经网络是深度学习中用于图像处理和识别的首选技术，通常使用反向传播算法进行训练。在 Parkhi、Vedaldi 和 Zisserman 于 2015 年进行的一项<a href="study">研究</a>中，他们开发了一个使用 18 层 CNN 和名人面部数据库的人脸识别系统。该网络使用反向传播在所有 18 层上进行训练，图像分批处理。研究人员使用了一种称为[三重损失](triplet loss)的损失函数来提高网络区分细微面部细微差别的能力。这涉及通过网络馈送三元组图像（例如，两张 Angelina Jolie 的图像和一张 Nicole Kidman 的图像），惩罚网络将同一人的图像错误分类为不同，以及将不同人的图像分类为相似。这个训练过程持续迭代，更新前一层的权重。<br>​<br><strong>NLP：语音识别</strong><br>​<br>反向传播已应用于训练各种 NLP 任务的神经网络，包括情感分析、语言翻译、文本生成和语音识别。使用反向传播训练的循环神经网络 (RNN) 通常用于 NLP 中的顺序数据处理。<br>​<br>例如，索尼开发了一个能够识别英语和日语有限命令的系统。该系统使用传入的声音信号分成时间窗口，应用[快速傅里叶变换](Fast Fourier Transform)提取基于频率的特征，然后将其输入到具有五层的神经网络中。反向传播用于训练这些层以理解日语命令，使用 softmax 交叉熵损失函数。研究人员能够通过再训练使同一网络适应识别英语命令，展示了迁移学习能力。<br>​<br><strong>事故预防</strong><br>​<br>由于地表资源的枯竭，地下矿井的数量正在增加。[本文](This paper)提供了一种改进地下矿井爆炸后重新进入时间预测的方法，这对于确保工人安全和生产力至关重要。目前，使用的方法（如固定时间间隔和经验公式）具有局限性，并且可能不具有普遍适用性。作者建议，反向传播神经网络可以成为一种解决方案。<br>​<br><strong>反向传播的历史</strong><br>​<br>在 19 世纪，法国数学家 Baron Augustin-Louis Cauchy 开发了一种称为梯度下降的方法来求解联立方程组。他的目标是解决涉及多个变量的复杂天文计算。Cauchy 的想法是求函数的导数并采取小步骤以最小化误差。<br>​<br>在接下来的一个世纪里，梯度下降方法在各个学科中得到了应用，为原本难以或无法通过代数解决的具有挑战性的问题提供了数值解。<br>​<br>1970 年，芬兰赫尔辛基大学的一名硕士生 Seppo Linnainmaa 提出了一种用于稀疏连接网络中误差反向传播的有效算法。尽管 Linnainmaa 没有特别提及神经网络，但他的工作为未来的发展奠定了基础。<br>​<br>在 20 世纪 80 年代，研究人员独立开发了时间反向传播，以支持循环神经网络的训练，进一步扩展了该算法的能力。<br>​<br>1986 年，美国心理学家 David Rumelhart 和他的同事发表了一篇极具影响力的论文，将 Linnainmaa 的反向传播算法应用于多层神经网络。这标志着一个重大的突破；随后的几年见证了基于该算法的进一步发展。例如，[Yann LeCun 1989 年的论文](Yann LeCun’s 1989 paper)展示了反向传播在卷积神经网络中用于手写数字识别的应用。<br>​<br>近年来，反向传播在深度神经网络的高效训练中发挥着至关重要的作用。虽然为了并行化算法和利用多个 GPU 已经进行了修改，但 Linnainmaa 开发并由 Rumelhart 推广的原始反向传播算法仍然是当代基于深度学习的人工智能的基础。<br>​<br>如果您想了解更多关于反向传播的详细的、基于数学的解释，请查看[这篇文章](this article)。<br>​<br><strong>结论</strong><br>​<br>反向传播作为深度学习的核心原理，在神经网络参与的许多领域中发挥着重要作用。通过促进神经网络内权重的微调，它有助于为几乎所有行业生成准确的预测和分类。然而，与任何技术一样，必须平衡效率和复杂性，了解算法的局限性，例如梯度下降与反向传播无法识别它是在误差函数的全局最小值还是局部最小值上工作，以及难以跨越误差函数景观中的平台。<br>​<br>为了克服这些局限性，已经出现了新的方法和其他优化器，这些方法在最新的科学论文中得到了广泛的体现。查看下面的一些出版物。<br>​</li>
</ol>
<ul>
<li>  [符号优化算法发现](Symbolic Discovery of Optimization Algorithms)  </li>
<li>  [Adam 优化器](Adam Optimizer)  </li>
<li>  [没有反向传播的优化](Optimization without backpropagation)<br>​<br>​</li>
</ul>
<p>然后。不小心。。。真的不小心整理了一下反向传播的涉及的知识篇。。。。真的不小心的。。。就整理了下面一堆东西了。😑太难了。以为AI 是风（疯）口。。。就扎进去了。。。现在真的疯了。。。。。。如果你也疯了。。请往下看</p>
<h1 id="疯点目录"><a href="#疯点目录" class="headerlink" title="疯点目录"></a>疯点目录</h1><p>根据提供的文章内容，整理出反向传播算法（Backpropagation）的学习知识目录列表，采用层级结构展示：</p>
<ul>
<li><p><strong>一级知识点 1：神经网络基础</strong></p>
<ul>
<li><p>二级知识点 1.1：神经元模型 (Neuron Model)</p>
<ul>
<li><p>三级知识点 1.1.1：输入和输出</p>
</li>
<li><p>三级知识点 1.1.2：权重 (Weights) 和阈值 (Biases&#x2F;Threshold)</p>
</li>
<li><p>三级知识点 1.1.3：激活函数 (Activation Function)</p>
</li>
</ul>
</li>
<li><p>二级知识点 1.2：神经网络结构 (Neural Network Structure)</p>
<ul>
<li><p>三级知识点 1.2.1：输入层 (Input Layer)</p>
</li>
<li><p>三级知识点 1.2.2：隐藏层 (Hidden Layer)</p>
</li>
<li><p>三级知识点 1.2.3：输出层 (Output Layer)</p>
</li>
<li><p>三级知识点 1.2.4：多层感知器 (Multilayer Perceptron, MLP)</p>
</li>
<li><p>三级知识点1.2.5: 前馈神经网络</p>
</li>
</ul>
</li>
<li><p>二级知识点 1.3：常见的神经网络类型</p>
<ul>
<li><p>三级知识点 1.3.1：卷积神经网络 (CNN)</p>
</li>
<li><p>三级知识点 1.3.2: 循环神经网络(RNN)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一级知识点 2：前向传播 (Forward Propagation)</strong></p>
<ul>
<li><p>二级知识点 2.1：前向传播过程</p>
</li>
<li><p>二级知识点 2.2：计算图 (Computational Graph)</p>
</li>
</ul>
</li>
<li><p><strong>一级知识点 3：反向传播 (Backpropagation)</strong></p>
<ul>
<li><p>二级知识点 3.1：反向传播的目的：计算梯度，更新权重</p>
</li>
<li><p>二级知识点 3.2：链式法则 (Chain Rule)</p>
</li>
<li><p>二级知识点 3.3：反向传播过程</p>
</li>
<li><p>二级知识点 3.4：反向传播的类型</p>
<ul>
<li><p>三级知识点 3.4.1：静态反向传播 (Static Backpropagation)</p>
</li>
<li><p>三级知识点 3.4.2：循环反向传播 (Recurrent Backpropagation)</p>
</li>
</ul>
</li>
<li><p>二级知识点3.5: BP神经网络</p>
</li>
</ul>
</li>
<li><p><strong>一级知识点 4：优化算法 (Optimization Algorithms)</strong></p>
<ul>
<li><p>二级知识点 4.1：梯度下降 (Gradient Descent)</p>
<ul>
<li><p>三级知识点 4.1.1：批量梯度下降 (Batch Gradient Descent)</p>
</li>
<li><p>三级知识点 4.1.2：小批量梯度下降 (Mini-batch Gradient Descent)</p>
</li>
<li><p>三级知识点 4.1.3：随机梯度下降 (Stochastic Gradient Descent)</p>
</li>
</ul>
</li>
<li><p>二级知识点 4.2：其他优化器 (Optimizers)</p>
<ul>
<li><p>三级知识点 4.2.1：Adam (Adaptive Moment Estimation)</p>
</li>
<li><p>三级知识点 4.2.2：其他 (AdaGrad, AdaDelta, Nesterov Accelerated Gradient, Sophia, etc.)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一级知识点5: 损失函数</strong></p>
<ul>
<li><p>二级知识点 5.1: 损失函数的定义</p>
</li>
<li><p>二级知识点 5.2: 不同任务的损失函数</p>
<ul>
<li><p>三级知识点 5.2.1: 分类任务</p>
</li>
<li><p>三级知识点 5.2.2: 回归任务</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一级知识点 6：反向传播的应用</strong></p>
<ul>
<li><p>二级知识点 6.1：人脸识别 (Face Recognition)</p>
</li>
<li><p>二级知识点 6.2：自然语言处理：语音识别 (NLP: Speech Recognition)</p>
</li>
<li><p>二级知识点 6.3: 事故预防</p>
</li>
</ul>
</li>
<li><p><strong>一级知识点 7：反向传播的历史</strong></p>
</li>
<li><p><strong>一级知识点8: 超参数</strong></p>
<ul>
<li><p>二级知识点 8.1: 输入图像大小</p>
</li>
<li><p>二级知识点 8.2: 学习率</p>
</li>
<li><p>二级知识点 8.3: 正则化参数</p>
</li>
<li><p>二级知识点 8.4: 神经网络层数</p>
</li>
<li><p>二级知识点 8.5: 批处理大小(batch size)</p>
</li>
<li><p>二级知识点 8.6: 卷积层参数</p>
</li>
<li><p>二级知识点 8.7: 池化层参数</p>
</li>
<li><p>二级知识点 8.8: 迭代周期</p>
</li>
</ul>
</li>
</ul>
<p>好的！虽然有点疯的目录看起来很鼓噪，那就让我们告别严肃的学术氛围，来点轻松幽默的风格，开启反向传播的学习之旅！</p>
<blockquote>
<p>哇哦！这篇文章真是信息量爆炸，就像一口气吞下了一整本神经网络的“天书”！😵‍💫 别担心，虽然内容有点多，但咱们可以像剥洋葱一样，一层一层地揭开反向传播的神秘面纱。🧅</p>
</blockquote>
<blockquote>
<p>不过，在正式开始“剥洋葱”之前，我们需要先整理一下“工具箱”🧰，也就是梳理一下知识点。毕竟，磨刀不误砍柴工嘛！🔪</p>
</blockquote>
<blockquote>
<p>想象一下，反向传播就像是一位“调皮”的神经网络教练，它会根据网络“学员”的表现（预测结果）来“敲打”它们，让它们不断改进，最终成为“学霸”！👨‍🎓👩‍🎓</p>
</blockquote>
<blockquote>
<p>那么，这位“教练”究竟有哪些“独门秘籍”呢？🤔 让我们一起列个清单，把这些“秘籍”分门别类，变成我们的学习路线图！🗺️</p>
</blockquote>
<p>接下来，我将按照之前提供的层级结构知识目录列表，开始 Step-by-step 的学习引导。准备好了吗？Let’s go! 🚀</p>
<h1 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h1><p><strong>一级知识点 1：神经网络基础 🧠</strong></p>
<p>在深入了解反向传播之前，我们需要先熟悉一下神经网络的基础知识。这就像盖房子要先打好地基一样重要！🧱</p>
<p><strong>二级知识点 1.1：神经元模型 💡</strong></p>
<p>神经元是神经网络的基本组成单位。你可以把它想象成一个“小精灵”🧚‍♀️，它接收一些输入信号，然后根据自己的“心情”（权重和偏置）做出反应，产生一个输出信号。</p>
<ul>
<li><p><strong>三级知识点 1.1.1：输入和输出 ➡️⬅️</strong> 神经元接收来自其他神经元的信号作为输入，然后产生一个信号作为输出。就像你听到朋友的笑话（输入），然后哈哈大笑（输出）一样。😆</p>
</li>
<li><p><strong>三级知识点 1.1.2：权重 (Weights) 和阈值 (Biases&#x2F;Threshold) ⚖️</strong> 每个输入信号都有一个权重，表示这个信号的重要性。权重越大，这个信号就越重要。阈值就像是一个“门槛”，只有当输入的加权和超过这个门槛时，神经元才会被“激活”，产生输出。 可以这样理解： 权重好比你对不同朋友的信任度，信任度越高，他们的话就越重要。 阈值好比你的笑点，只有笑话足够好笑（超过笑点），你才会笑出来。😄</p>
</li>
<li><p><strong>三级知识点 1.1.3：激活函数 (Activation Function) 🔥</strong> 激活函数就像是神经元的“情绪调节器”，它将输入的加权和转换成一个输出信号。激活函数有很多种，每种都有不同的“调节”效果。 例如，Sigmoid 函数可以将输入压缩到 0 到 1 之间，就像把神经元的“情绪”控制在一个温和的范围内。😌</p>
</li>
</ul>
<p><strong>二级知识点 1.2：神经网络结构 🏗️</strong></p>
<p>神经网络是由许多神经元相互连接而成的。这些神经元按照不同的层次排列，形成了不同的网络结构。</p>
<ul>
<li><p><strong>三级知识点 1.2.1：输入层 (Input Layer) 📥</strong> 输入层负责接收外部数据。就像你的眼睛 👀 和耳朵 👂 负责接收外界的信息一样。</p>
</li>
<li><p><strong>三级知识点 1.2.2：隐藏层 (Hidden Layer) 🕵️</strong> 隐藏层是神经网络的“大脑”，负责处理输入数据，提取特征。隐藏层可以有很多层，层数越多，网络就越复杂，处理能力也越强。就像福尔摩斯的大脑一样，层层推理，最终找出真相！🔍</p>
</li>
<li><p><strong>三级知识点 1.2.3：输出层 (Output Layer) 📤</strong> 输出层负责产生网络的最终输出。就像你的嘴巴 👄，负责说出你的想法。</p>
</li>
<li><p><strong>三级知识点 1.2.4：多层感知器 (Multilayer Perceptron, MLP) 🏢</strong> 多层感知器是一种常见的神经网络结构，它由多个层次的神经元组成，每一层的神经元都与下一层的所有神经元相连。 你可以把多层感知器想象成一栋大楼，每一层都有很多房间（神经元），每个房间都与下一层的所有房间相连。🏢</p>
</li>
<li><p><strong>三级知识点 1.2.5：前馈神经网络 ➡️</strong> 在前馈神经网络中，信息只能从输入层流向输出层，不能反向流动。就像单行道一样，只能前进，不能后退。🚗</p>
</li>
</ul>
<p><strong>二级知识点1.3: 常见的神经网络类型</strong> * <strong>三级知识点 1.3.1：卷积神经网络 (CNN) 🖼️</strong> 卷积神经网络特别擅长处理图像。 比如识别人脸， 自动驾驶。 * <strong>三级知识点 1.3.2：循环神经网络 (RNN) ✍️</strong> 循环神经网络更适合处理有顺序的信息， 比如分析一段话， 预测下一秒钟的股票价格。</p>
<h1 id="前向传播-Forward-Propagation"><a href="#前向传播-Forward-Propagation" class="headerlink" title="前向传播 (Forward Propagation)"></a>前向传播 (Forward Propagation)</h1><p><strong>一级知识点 2：前向传播 (Forward Propagation) ➡️</strong></p>
<p>前向传播是神经网络处理信息的过程，就像水流顺着管道流动一样自然。💧</p>
<ul>
<li><p><strong>二级知识点 2.1：前向传播过程 🚶</strong></p>
<ol>
<li><p><strong>数据输入:</strong> 首先，我们将数据（例如一张图片 🖼️ 或一段文字 📝）输入到神经网络的输入层。</p>
</li>
<li><p><strong>逐层传递:</strong> 数据从输入层开始，逐层通过隐藏层。每一层的神经元都会对接收到的数据进行加权求和，然后通过激活函数进行处理，产生输出。就像接力赛一样，每一棒的选手（神经元）都会把接力棒（数据）传递给下一棒。🏃‍♀️🏃‍♂️</p>
</li>
<li><p><strong>输出结果:</strong> 最后，数据到达输出层，产生网络的最终输出结果。这个结果可能是对图片的分类、对文字的翻译等等。</p>
</li>
</ol>
</li>
<li><p><strong>二级知识点 2.2：计算图 (Computational Graph) 📊</strong></p>
<p>  为了更好地理解前向传播和后续的反向传播过程，我们可以使用计算图来表示。</p>
<ul>
<li><p>计算图是一种有向图，它将计算过程表示为一系列节点和边。</p>
</li>
<li><p>节点表示计算操作（例如加法、乘法、激活函数等），边表示数据流动的方向。</p>
</li>
<li><p>通过计算图，我们可以清晰地看到数据是如何在神经网络中流动的，以及每个节点是如何参与计算的。</p>
</li>
</ul>
<p>  举个例子：假设我们要计算 <code>y = (x + w) * b</code>，我们可以用计算图表示为：</p>
<p>  x —-(+)—-(*)—- y<br>   |     ^     ^<br>   |     |     |<br>   w —-|     b —-|</p>
<p>  在这个图中，<code>x</code>、<code>w</code>、<code>b</code> 是输入节点，<code>(+)</code> 和 <code>(*)</code> 是计算节点，<code>y</code> 是输出节点。数据从输入节点流向输出节点，完成了计算过程。</p>
</li>
</ul>
<p>前向传播就像是神经网络的“思考”过程，它根据输入数据和当前的权重，一步一步地计算出最终的输出结果。🤔</p>
<p>现在，你已经了解了前向传播的过程了！请你思考一下：</p>
<ul>
<li><p>你能用自己的话描述一下前向传播的过程吗？🗣️</p>
</li>
<li><p>你能画出一个简单的神经网络的计算图吗？✍️</p>
</li>
</ul>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p><strong>二级知识点 1.1：神经元模型 💡</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们有一个简单的神经元，用于判断一封邮件是否是垃圾邮件。</p>
<ul>
<li><p><strong>输入 (Inputs):</strong></p>
<ul>
<li><p>x1: 邮件中包含“免费”一词的次数 (例如：3)</p>
</li>
<li><p>x2: 邮件中包含链接的数量 (例如：5)</p>
</li>
<li><p>x3: 发件人是否在已知的垃圾邮件发送者列表中 (1 表示是，0 表示否) (例如：1)</p>
</li>
</ul>
</li>
<li><p><strong>权重 (Weights):</strong></p>
<ul>
<li><p>w1: 0.8 (表示“免费”一词的重要性)</p>
</li>
<li><p>w2: 0.5 (表示链接数量的重要性)</p>
</li>
<li><p>w3: 1.2 (表示发件人是否在垃圾邮件列表中的重要性)</p>
</li>
</ul>
</li>
<li><p><strong>偏置 (Bias):</strong></p>
<ul>
<li>b: -1.0</li>
</ul>
</li>
<li><p><strong>激活函数 (Activation Function):</strong></p>
<ul>
<li>Sigmoid 函数：σ(z) &#x3D; 1 &#x2F; (1 + exp(-z)) （将输出压缩到 0-1 之间）</li>
</ul>
</li>
</ul>
<p>  <strong>计算过程:</strong></p>
<ol>
<li><p><strong>加权和 (Weighted Sum):</strong> z &#x3D; (x1 * w1) + (x2 * w2) + (x3 * w3) + b z &#x3D; (3 * 0.8) + (5 * 0.5) + (1 * 1.2) + (-1.0) &#x3D; 2.4 + 2.5 + 1.2 - 1.0 &#x3D; 5.1</p>
</li>
<li><p><strong>激活函数 (Activation):</strong> output &#x3D; σ(z) &#x3D; 1 &#x2F; (1 + exp(-5.1)) ≈ 0.994</p>
</li>
</ol>
<p>  <strong>结论:</strong> 输出值接近 1，表示这个神经元认为这封邮件很可能是垃圾邮件。</p>
<p>  <strong>PyTorch 代码片段:</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="定义神经元-单层线性模型-Sigmoid-激活函数"><a href="#定义神经元-单层线性模型-Sigmoid-激活函数" class="headerlink" title="定义神经元 (单层线性模型 + Sigmoid 激活函数)"></a>定义神经元 (单层线性模型 + Sigmoid 激活函数)</h1><p>  class Neuron(nn.Module):<br>      def <strong>init</strong>(self):<br>          super().<strong>init</strong>()<br>          self.linear &#x3D; nn.Linear(3, 1)  # 输入维度为 3，输出维度为 1<br>          self.sigmoid &#x3D; nn.Sigmoid()<br>  ​<br>      def forward(self, x):<br>          return self.sigmoid(self.linear(x))<br>  ​  </p>
<h1 id="创建神经元实例"><a href="#创建神经元实例" class="headerlink" title="创建神经元实例"></a>创建神经元实例</h1><p>  neuron &#x3D; Neuron()<br>  ​  </p>
<h1 id="设置权重和偏置-手动设置，实际应用中通过训练学习"><a href="#设置权重和偏置-手动设置，实际应用中通过训练学习" class="headerlink" title="设置权重和偏置 (手动设置，实际应用中通过训练学习)"></a>设置权重和偏置 (手动设置，实际应用中通过训练学习)</h1><p>  neuron.linear.weight.data &#x3D; torch.tensor([[0.8, 0.5, 1.2]])<br>  neuron.linear.bias.data &#x3D; torch.tensor([-1.0])<br>  ​  </p>
<h1 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h1><p>  x &#x3D; torch.tensor([3.0, 5.0, 1.0])  # 注意：输入数据类型需为浮点数<br>  ​  </p>
<h1 id="计算输出"><a href="#计算输出" class="headerlink" title="计算输出"></a>计算输出</h1><p>  output &#x3D; neuron(x)<br>  print(f”神经元输出: {output.item():.3f}”)  # 输出: 神经元输出: 0.994</p>
</li>
</ul>
<p><strong>二级知识点 1.2：神经网络结构 🏗️</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们要构建一个简单的多层感知器 (MLP) 来识别手写数字（0-9）。</p>
<ul>
<li><p><strong>输入层 (Input Layer):</strong> 784 个神经元 (28x28 像素的图像)</p>
</li>
<li><p><strong>隐藏层 (Hidden Layer):</strong> 128 个神经元 (使用 ReLU 激活函数)</p>
</li>
<li><p><strong>输出层 (Output Layer):</strong> 10 个神经元 (分别代表 0-9 十个数字，使用 Softmax 激活函数)</p>
</li>
</ul>
<p>  <strong>图示:</strong></p>
<p>  [输入层]      [隐藏层]       [输出层]<br>  (784 个)      (128 个)       (10 个)<br>  O O O … O   O O O … O    O O O … O<br>  O O O … O   O O O … O    O O O … O<br>  …          …            …<br>  O O O … O   O O O … O    O O O … O</p>
<p>  <strong>PyTorch 代码片段:</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="定义多层感知器-MLP"><a href="#定义多层感知器-MLP" class="headerlink" title="定义多层感知器 (MLP)"></a>定义多层感知器 (MLP)</h1><p>  class MLP(nn.Module):<br>      def <strong>init</strong>(self):<br>          super().<strong>init</strong>()<br>          self.flatten &#x3D; nn.Flatten()  # 将 28x28 的图像展平为 784 维向量<br>          self.linear1 &#x3D; nn.Linear(784, 128)  # 输入层到隐藏层<br>          self.relu &#x3D; nn.ReLU()  # ReLU 激活函数<br>          self.linear2 &#x3D; nn.Linear(128, 10)  # 隐藏层到输出层<br>          self.softmax &#x3D; nn.Softmax(dim&#x3D;1)  # Softmax 激活函数 (dim&#x3D;1 表示对每一行进行 Softmax)<br>  ​<br>      def forward(self, x):<br>          x &#x3D; self.flatten(x)<br>          x &#x3D; self.relu(self.linear1(x))<br>          x &#x3D; self.softmax(self.linear2(x))<br>          return x<br>  ​  </p>
<h1 id="创建-MLP-实例"><a href="#创建-MLP-实例" class="headerlink" title="创建 MLP 实例"></a>创建 MLP 实例</h1><p>  mlp &#x3D; MLP()<br>  ​  </p>
<h1 id="模拟输入数据-一张-28x28-的手写数字图像"><a href="#模拟输入数据-一张-28x28-的手写数字图像" class="headerlink" title="模拟输入数据 (一张 28x28 的手写数字图像)"></a>模拟输入数据 (一张 28x28 的手写数字图像)</h1><p>  input_data &#x3D; torch.randn(1, 28, 28)  # (batch_size, height, width)<br>  ​  </p>
<h1 id="计算输出-1"><a href="#计算输出-1" class="headerlink" title="计算输出"></a>计算输出</h1><p>  output &#x3D; mlp(input_data)<br>  print(f”MLP 输出: {output}”)  # 输出一个 1x10 的概率分布</p>
</li>
</ul>
<p><strong>一级知识点 2：前向传播 ➡️</strong></p>
<p><strong>二级知识点 2.1：前向传播过程 🚶</strong></p>
<ul>
<li><p><strong>范例:</strong> 沿用上面的 MLP 识别手写数字的例子，我们来看前向传播的具体过程：</p>
<ol>
<li><p><strong>输入图像:</strong> 将一张 28x28 的手写数字图像 (例如数字 “3”) 输入到 MLP 的输入层。图像的每个像素值 (0-255) 对应输入层的一个神经元。</p>
</li>
<li><p><strong>展平:</strong> 将 28x28 的二维图像展平为 784 维的一维向量。</p>
</li>
<li><p><strong>输入层到隐藏层:</strong></p>
<ul>
<li><p>对 784 维的输入向量进行加权求和：每个输入值乘以对应的权重，然后加上偏置。</p>
</li>
<li><p>应用 ReLU 激活函数：将加权和的结果输入到 ReLU 函数中，得到隐藏层的输出。</p>
</li>
</ul>
</li>
<li><p><strong>隐藏层到输出层:</strong></p>
<ul>
<li><p>对 128 维的隐藏层输出进行加权求和：每个隐藏层输出值乘以对应的权重，然后加上偏置。</p>
</li>
<li><p>应用 Softmax 激活函数：将加权和的结果输入到 Softmax 函数中，得到一个 10 维的概率分布向量。向量的每个元素表示对应数字的概率。</p>
</li>
</ul>
</li>
<li><p><strong>输出结果:</strong> 输出层产生一个 10 维的概率分布向量，其中概率最高的元素对应的数字就是 MLP 的预测结果。例如，如果输出向量中第 4 个元素 (索引为 3) 的概率最高，则 MLP 预测这张图片是数字 “3”。</p>
</li>
</ol>
</li>
</ul>
<p><strong>二级知识点 2.2：计算图 📊</strong> 前向传播流程图与神经网络结构图基本一致.</p>
<h1 id="反向传播-Backpropagation"><a href="#反向传播-Backpropagation" class="headerlink" title="反向传播 (Backpropagation)"></a>反向传播 (Backpropagation)</h1><p><strong>一级知识点 3：反向传播 (Backpropagation) 🔄</strong></p>
<p>如果说前向传播是神经网络的“思考”过程，那么反向传播就是神经网络的“反思”和“学习”过程。🤔</p>
<ul>
<li><p><strong>二级知识点 3.1：反向传播的目的：计算梯度，更新权重 🎯</strong></p>
<ul>
<li><p><strong>计算梯度 (Calculate Gradients):</strong> 反向传播的核心目的是计算损失函数相对于神经网络中每个权重和偏置的梯度。梯度表示了损失函数的变化趋势，指明了权重和偏置应该如何调整才能减少损失。</p>
<ul>
<li>你可以把梯度想象成一个“指南针”🧭，它指引着权重和偏置朝着“损失最小化”的方向前进。</li>
</ul>
</li>
<li><p><strong>更新权重 (Update Weights):</strong> 一旦计算出梯度，就可以使用优化算法（例如梯度下降）来更新神经网络中的权重和偏置。通过不断地调整权重和偏置，神经网络的预测结果会越来越准确。</p>
<ul>
<li>这个过程就像是“雕刻家”👨‍🎨 不断地调整“雕塑”的细节，使其越来越接近理想的形状。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二级知识点 3.2：链式法则 (Chain Rule) 🔗</strong></p>
<p>  反向传播算法的核心是微积分中的链式法则。链式法则用于计算复合函数的导数。</p>
<ul>
<li><p><strong>简单例子:</strong> 假设你有两个函数：<code>y = f(u)</code> 和 <code>u = g(x)</code>，那么 <code>y</code> 关于 <code>x</code> 的导数可以通过链式法则计算： <code>dy/dx = (dy/du) * (du/dx)</code></p>
</li>
<li><p><strong>在神经网络中:</strong> 神经网络可以看作是一个非常复杂的复合函数。每一层都可以看作是一个函数，将前一层的输出作为输入，产生当前层的输出。反向传播利用链式法则，从输出层开始，逐层计算损失函数相对于每个权重和偏置的梯度。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 3.3：反向传播过程 ⏪</strong></p>
<ol>
<li><p><strong>前向传播:</strong> 首先，进行一次前向传播，计算出网络的输出和损失。</p>
</li>
<li><p><strong>计算输出层梯度:</strong> 计算损失函数相对于输出层神经元输出的梯度。</p>
</li>
<li><p><strong>反向传播梯度:</strong> 从输出层开始，逐层向前计算梯度。</p>
<ul>
<li><p>使用链式法则，计算损失函数相对于每一层权重和偏置的梯度。</p>
</li>
<li><p>将梯度传递到前一层。</p>
</li>
</ul>
</li>
<li><p><strong>更新权重和偏置:</strong> 使用优化算法（例如梯度下降），根据计算出的梯度更新权重和偏置。</p>
</li>
</ol>
<p>  <strong>形象比喻:</strong> 想象你正在玩一个“猜数字”游戏。🤖</p>
<ol>
<li><p><strong>前向传播:</strong> 你猜一个数字 (输入)，然后朋友告诉你猜的数字是大了还是小了 (输出&#x2F;损失)。</p>
</li>
<li><p><strong>反向传播:</strong> 你根据朋友的反馈 (损失)，反思自己猜数字的策略 (权重)，并调整自己的策略 (更新权重)，以便下次猜得更准。</p>
</li>
</ol>
</li>
<li><p><strong>二级知识点 3.4：反向传播的类型</strong></p>
<ul>
<li><p><strong>三级知识点 3.4.1：静态反向传播 (Static Backpropagation)</strong> 处理每一次输入都是独立的，没有前后关联的情况。</p>
</li>
<li><p><strong>三级知识点 3.4.2：循环反向传播 (Recurrent Backpropagation)</strong> 用于处理序列数据，如文本或时间序列，其中当前输入与之前的输入有关联。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点3.5: BP神经网络</strong> 使用反向传播算法的神经网络。</p>
</li>
</ul>
<p>反向传播是神经网络学习的核心，它使得神经网络能够从错误中学习，不断提高自己的性能。💪</p>
<p>现在，你已经了解了反向传播的基本原理和过程。请思考：</p>
<ul>
<li><p>你能用自己的话解释反向传播的目的和过程吗？</p>
</li>
<li><p>链式法则在反向传播中起到了什么作用？</p>
</li>
</ul>
<h2 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h2><p>为反向传播 (Backpropagation) 这一关键概念提供更具体的范例，并结合 PyTorch 代码进行说明，让它更易于理解。</p>
<p><strong>一级知识点 3：反向传播 (Backpropagation) 🔄</strong></p>
<p><strong>二级知识点 3.1：反向传播的目的：计算梯度，更新权重 🎯</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们有一个非常简单的神经网络，只有一个输入 <code>x</code>、一个权重 <code>w</code>、一个偏置 <code>b</code> 和一个输出 <code>y</code>。我们的目标是预测 <code>y_true</code>。</p>
<ul>
<li><p><strong>模型:</strong> <code>y = w * x + b</code></p>
</li>
<li><p><strong>损失函数 (Loss Function):</strong> 均方误差 (Mean Squared Error, MSE)：<code>L = (y - y_true)^2</code></p>
</li>
<li><p><strong>目标:</strong> 找到合适的 <code>w</code> 和 <code>b</code>，使得损失函数 <code>L</code> 最小化。</p>
</li>
</ul>
<p>  <strong>计算梯度 (Calculate Gradients):</strong></p>
<ol>
<li><p><strong>∂L&#x2F;∂y:</strong> 损失函数 <code>L</code> 相对于模型输出 <code>y</code> 的梯度。 <code>∂L/∂y = 2 * (y - y_true)</code></p>
</li>
<li><p><strong>∂y&#x2F;∂w:</strong> 模型输出 <code>y</code> 相对于权重 <code>w</code> 的梯度。 <code>∂y/∂w = x</code></p>
</li>
<li><p><strong>∂y&#x2F;∂b:</strong> 模型输出 <code>y</code> 相对于偏置 <code>b</code> 的梯度。 <code>∂y/∂b = 1</code></p>
</li>
<li><p><strong>∂L&#x2F;∂w:</strong> 损失函数 <code>L</code> 相对于权重 <code>w</code> 的梯度 (使用链式法则)。 <code>∂L/∂w = (∂L/∂y) * (∂y/∂w) = 2 * (y - y_true) * x</code></p>
</li>
<li><p><strong>∂L&#x2F;∂b:</strong> 损失函数 <code>L</code> 相对于偏置 <code>b</code> 的梯度 (使用链式法则)。 <code>∂L/∂b = (∂L/∂y) * (∂y/∂b) = 2 * (y - y_true) * 1 = 2 * (y - y_true)</code></p>
</li>
</ol>
<p>  <strong>更新权重 (Update Weights):</strong></p>
<ul>
<li><p><strong>学习率 (Learning Rate):</strong> <code>lr</code> (例如：0.1)</p>
</li>
<li><p><strong>权重更新:</strong> <code>w = w - lr * (∂L/∂w)</code></p>
</li>
<li><p><strong>偏置更新:</strong> <code>b = b - lr * (∂L/∂b)</code></p>
</li>
</ul>
<p>  <strong>PyTorch 代码片段:</strong></p>
<p>  import torch<br>  ​  </p>
<h1 id="输入、权重、偏置、真实值"><a href="#输入、权重、偏置、真实值" class="headerlink" title="输入、权重、偏置、真实值"></a>输入、权重、偏置、真实值</h1><p>  x &#x3D; torch.tensor(2.0, requires_grad&#x3D;True)  # requires_grad&#x3D;True 表示需要计算梯度<br>  w &#x3D; torch.tensor(1.0, requires_grad&#x3D;True)<br>  b &#x3D; torch.tensor(0.5, requires_grad&#x3D;True)<br>  y_true &#x3D; torch.tensor(5.0)<br>  ​  </p>
<h1 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h1><p>  y &#x3D; w * x + b<br>  ​  </p>
<h1 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h1><p>  loss &#x3D; (y - y_true)**2<br>  ​  </p>
<h1 id="反向传播-自动计算梯度"><a href="#反向传播-自动计算梯度" class="headerlink" title="反向传播 (自动计算梯度)"></a>反向传播 (自动计算梯度)</h1><p>  loss.backward()<br>  ​  </p>
<h1 id="打印梯度"><a href="#打印梯度" class="headerlink" title="打印梯度"></a>打印梯度</h1><p>  print(f”∂L&#x2F;∂w: {w.grad}”)  # ∂L&#x2F;∂w: -8.0<br>  print(f”∂L&#x2F;∂b: {b.grad}”)  # ∂L&#x2F;∂b: -4.0<br>  ​  </p>
<h1 id="更新权重和偏置-手动更新，实际应用中通常使用优化器"><a href="#更新权重和偏置-手动更新，实际应用中通常使用优化器" class="headerlink" title="更新权重和偏置 (手动更新，实际应用中通常使用优化器)"></a>更新权重和偏置 (手动更新，实际应用中通常使用优化器)</h1><p>  lr &#x3D; 0.1<br>  with torch.no_grad():  # 在更新权重和偏置时，不需要计算梯度<br>      w -&#x3D; lr * w.grad<br>      b -&#x3D; lr * b.grad<br>  ​<br>      # 清空梯度 (重要！否则梯度会累积)<br>      w.grad.zero_()<br>      b.grad.zero_()<br>  ​<br>  print(f”更新后的权重 w: {w.item()}”)  # 更新后的权重 w: 1.8<br>  print(f”更新后的偏置 b: {b.item()}”)  # 更新后的偏置 b: 0.9</p>
</li>
</ul>
<p><strong>二级知识点 3.2：链式法则 (Chain Rule) 🔗</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们有一个稍微复杂一点的神经网络：</p>
<ul>
<li><p><strong>第一层:</strong> <code>y1 = w1 * x + b1</code></p>
</li>
<li><p><strong>第二层:</strong> <code>y2 = w2 * y1 + b2</code></p>
</li>
<li><p><strong>损失函数:</strong> <code>L = (y2 - y_true)^2</code></p>
</li>
</ul>
<p>  我们要计算损失函数 <code>L</code> 相对于 <code>w1</code> 的梯度 <code>∂L/∂w1</code>。</p>
<p>  <strong>链式法则分解:</strong></p>
<ol>
<li><p><strong>∂L&#x2F;∂y2:</strong> 损失函数 <code>L</code> 相对于第二层输出 <code>y2</code> 的梯度。 <code>∂L/∂y2 = 2 * (y2 - y_true)</code></p>
</li>
<li><p><strong>∂y2&#x2F;∂y1:</strong> 第二层输出 <code>y2</code> 相对于第一层输出 <code>y1</code> 的梯度。 <code>∂y2/∂y1 = w2</code></p>
</li>
<li><p><strong>∂y1&#x2F;∂w1:</strong> 第一层输出 <code>y1</code> 相对于权重 <code>w1</code> 的梯度。 <code>∂y1/∂w1 = x</code></p>
</li>
<li><p><strong>∂L&#x2F;∂w1:</strong> 损失函数 <code>L</code> 相对于权重 <code>w1</code> 的梯度 (使用链式法则)。 <code>∂L/∂w1 = (∂L/∂y2) * (∂y2/∂y1) * (∂y1/∂w1) = 2 * (y2 - y_true) * w2 * x</code></p>
</li>
</ol>
<p>  <strong>PyTorch 代码片段 (演示自动微分):</strong></p>
<p>  import torch<br>  ​  </p>
<h1 id="输入、权重、偏置、真实值-1"><a href="#输入、权重、偏置、真实值-1" class="headerlink" title="输入、权重、偏置、真实值"></a>输入、权重、偏置、真实值</h1><p>  x &#x3D; torch.tensor(2.0, requires_grad&#x3D;True)<br>  w1 &#x3D; torch.tensor(1.0, requires_grad&#x3D;True)<br>  b1 &#x3D; torch.tensor(0.5, requires_grad&#x3D;True)<br>  w2 &#x3D; torch.tensor(2.0, requires_grad&#x3D;True)<br>  b2 &#x3D; torch.tensor(1.0, requires_grad&#x3D;True)<br>  y_true &#x3D; torch.tensor(8.0)<br>  ​  </p>
<h1 id="前向传播-1"><a href="#前向传播-1" class="headerlink" title="前向传播"></a>前向传播</h1><p>  y1 &#x3D; w1 * x + b1<br>  y2 &#x3D; w2 * y1 + b2<br>  ​  </p>
<h1 id="计算损失-1"><a href="#计算损失-1" class="headerlink" title="计算损失"></a>计算损失</h1><p>  loss &#x3D; (y2 - y_true)**2<br>  ​  </p>
<h1 id="反向传播-自动计算梯度-1"><a href="#反向传播-自动计算梯度-1" class="headerlink" title="反向传播 (自动计算梯度)"></a>反向传播 (自动计算梯度)</h1><p>  loss.backward()<br>  ​  </p>
<h1 id="打印梯度-1"><a href="#打印梯度-1" class="headerlink" title="打印梯度"></a>打印梯度</h1><p>  print(f”∂L&#x2F;∂w1: {w1.grad}”)  # ∂L&#x2F;∂w1: -24.0<br>  ​  </p>
<h1 id="省略权重和偏置的更新步骤，与前面的例子类似"><a href="#省略权重和偏置的更新步骤，与前面的例子类似" class="headerlink" title="(省略权重和偏置的更新步骤，与前面的例子类似)"></a>(省略权重和偏置的更新步骤，与前面的例子类似)</h1></li>
</ul>
<p><strong>二级知识点 3.3：反向传播过程 ⏪</strong></p>
<ul>
<li><p><strong>结合 MLP 的范例:</strong></p>
<p>  回顾一下我们之前用于识别手写数字的 MLP（输入层 784 个神经元，隐藏层 128 个神经元，输出层 10 个神经元）。</p>
<p>  <strong>反向传播过程:</strong></p>
<ol>
<li><p><strong>前向传播:</strong> 输入一张手写数字图像，经过 MLP 的前向传播，得到输出层的预测概率分布。</p>
</li>
<li><p><strong>计算损失:</strong> 使用交叉熵损失函数 (Cross-Entropy Loss) 计算预测概率分布与真实标签 (one-hot 编码) 之间的差异。</p>
</li>
<li><p><strong>计算输出层梯度:</strong> 计算损失函数相对于输出层神经元输出的梯度。</p>
</li>
<li><p><strong>反向传播梯度 (隐藏层到输出层):</strong></p>
<ul>
<li><p>计算损失函数相对于输出层权重和偏置的梯度 (使用链式法则)。</p>
</li>
<li><p>计算损失函数相对于隐藏层输出的梯度 (使用链式法则)。</p>
</li>
</ul>
</li>
<li><p><strong>反向传播梯度 (输入层到隐藏层):</strong></p>
<ul>
<li><p>计算损失函数相对于隐藏层权重和偏置的梯度 (使用链式法则)。</p>
</li>
<li><p>计算损失函数相对于输入层输出的梯度 (使用链式法则，但通常不需要更新输入层的权重)。</p>
</li>
</ul>
</li>
<li><p><strong>更新权重和偏置:</strong> 使用优化算法 (例如 Adam)，根据计算出的梯度更新所有层的权重和偏置。</p>
</li>
</ol>
</li>
</ul>
<h1 id="优化算法-Optimization-Algorithms"><a href="#优化算法-Optimization-Algorithms" class="headerlink" title="优化算法 (Optimization Algorithms)"></a>优化算法 (Optimization Algorithms)</h1><p>OK！准备好迎接优化算法了吗？它们可是反向传播的“神助攻”！💪</p>
<p><strong>一级知识点 4：优化算法 (Optimization Algorithms) ⚙️</strong></p>
<p>优化算法在神经网络训练中扮演着至关重要的角色。它们利用反向传播计算出的梯度，来更新网络的权重和偏置，目标是找到使损失函数最小化的参数值。</p>
<ul>
<li><p><strong>二级知识点 4.1：梯度下降 (Gradient Descent) ⛰️</strong></p>
<p>  梯度下降是最基本、最常用的优化算法。它就像一个“探险家”🚶，沿着梯度的反方向（最陡峭的下坡方向）前进，一步一步地寻找“山谷”（损失函数的最小值）。</p>
<ul>
<li><p><strong>核心思想:</strong></p>
<ul>
<li><p>计算损失函数相对于每个参数（权重和偏置）的梯度。</p>
</li>
<li><p>沿着梯度的反方向更新参数：<code>参数 = 参数 - 学习率 * 梯度</code></p>
</li>
<li><p>学习率 (Learning Rate) 控制着每次更新的步长。学习率太大可能会“跨过”最小值，太小则可能导致收敛速度过慢。</p>
</li>
</ul>
</li>
<li><p><strong>三级知识点 4.1.1：批量梯度下降 (Batch Gradient Descent) 🐢</strong></p>
<ul>
<li><p>每次迭代使用整个训练数据集来计算梯度和更新参数。</p>
</li>
<li><p><strong>优点:</strong> 稳定，能够保证收敛到局部最小值（对于凸函数，可以收敛到全局最小值）。</p>
</li>
<li><p><strong>缺点:</strong> 速度慢，特别是对于大型数据集，计算量巨大。</p>
</li>
</ul>
</li>
<li><p><strong>三级知识点 4.1.2：小批量梯度下降 (Mini-batch Gradient Descent) 🐇</strong></p>
<ul>
<li><p>每次迭代使用训练数据集的一个子集（称为“批次” batch）来计算梯度和更新参数。</p>
</li>
<li><p><strong>优点:</strong> 速度比批量梯度下降快，计算量较小，同时又能保持一定的稳定性。</p>
</li>
<li><p><strong>缺点:</strong> 可能会在最小值附近震荡。</p>
</li>
</ul>
</li>
<li><p><strong>三级知识点 4.1.3：随机梯度下降 (Stochastic Gradient Descent) 🚀</strong></p>
<ul>
<li><p>每次迭代只使用一个训练样本来计算梯度和更新参数。</p>
</li>
<li><p><strong>优点:</strong> 速度非常快，适合于大型数据集和在线学习。</p>
</li>
<li><p><strong>缺点:</strong> 非常不稳定，可能会在最小值附近剧烈震荡，甚至无法收敛。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二级知识点 4.2：其他优化器 (Optimizers) ✨</strong></p>
<p>  除了梯度下降，还有许多更高级、更有效的优化算法。它们通常在梯度下降的基础上进行改进，以解决梯度下降的局限性，例如收敛速度慢、容易陷入局部最小值等问题。</p>
<ul>
<li><p><strong>三级知识点 4.2.1：Adam (Adaptive Moment Estimation) 🤖</strong></p>
<ul>
<li><p>Adam 是一种自适应学习率优化算法，它结合了动量法 (Momentum) 和 RMSprop 的思想。</p>
</li>
<li><p><strong>优点:</strong> 收敛速度快，对超参数的设置不敏感，通常表现良好。</p>
</li>
<li><p><strong>原理 (简要):</strong></p>
<ul>
<li><p><strong>动量 (Momentum):</strong> 考虑了之前梯度的累积效应，有助于加速收敛并减少震荡。</p>
</li>
<li><p><strong>RMSprop:</strong> 对每个参数使用不同的学习率，根据参数梯度的历史平方均值进行调整，有助于处理稀疏梯度和非平稳目标函数。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>三级知识点 4.2.2：其他 (AdaGrad, AdaDelta, Nesterov Accelerated Gradient, Sophia, etc.) 🤓</strong></p>
<ul>
<li><p><strong>AdaGrad:</strong> 自适应学习率算法，对不频繁更新的参数使用更大的学习率，对频繁更新的参数使用更小的学习率。</p>
</li>
<li><p><strong>AdaDelta:</strong> AdaGrad 的改进版，解决了 AdaGrad 学习率单调递减的问题。</p>
</li>
<li><p><strong>Nesterov Accelerated Gradient (NAG):</strong> 在动量法的基础上进行改进，通过在计算梯度时“向前看一步”，提高了收敛速度。</p>
</li>
<li><p><strong>Sophia:</strong> 一种新的二阶优化算法, 在一些情况下能获得比Adam更好的结果.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>优化算法的选择对于神经网络的训练至关重要。选择合适的优化算法可以加速训练过程，提高模型性能。</p>
<p>现在，你已经了解了优化算法的基本概念和常见类型。请思考：</p>
<ul>
<li><p>你能用自己的话解释梯度下降算法的原理吗？</p>
</li>
<li><p>不同的梯度下降变体（批量、小批量、随机）有什么区别？</p>
</li>
<li><p>Adam 优化器有哪些优点？</p>
</li>
</ul>
<h2 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h2><p>好的，我们来为优化算法 (Optimization Algorithms) 提供更具体的范例，并结合 PyTorch 代码进行说明，让它们更加生动易懂。</p>
<p><strong>一级知识点 4：优化算法 (Optimization Algorithms) ⚙️</strong></p>
<p><strong>二级知识点 4.1：梯度下降 (Gradient Descent) ⛰️</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们要使用梯度下降来解决一个简单的线性回归问题。</p>
<ul>
<li><p><strong>模型:</strong> <code>y = w * x + b</code></p>
</li>
<li><p><strong>数据集:</strong> 假设我们有一些 (x, y) 数据点，例如：</p>
<ul>
<li><p>(x&#x3D;1, y&#x3D;2)</p>
</li>
<li><p>(x&#x3D;2, y&#x3D;4)</p>
</li>
<li><p>(x&#x3D;3, y&#x3D;5)</p>
</li>
<li><p>(x&#x3D;4, y&#x3D;4)</p>
</li>
<li><p>(x&#x3D;5, y&#x3D;5)</p>
</li>
</ul>
</li>
<li><p><strong>损失函数:</strong> 均方误差 (MSE)：<code>L = (1/n) * Σ(y_pred - y_true)^2</code> (n 是样本数量)</p>
</li>
<li><p><strong>目标:</strong> 找到合适的 <code>w</code> 和 <code>b</code>，使得损失函数 <code>L</code> 最小化。</p>
</li>
</ul>
<p>  <strong>批量梯度下降 (Batch Gradient Descent):</strong></p>
<p>  import torch<br>  import numpy as np<br>  ​  </p>
<h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p>  x &#x3D; torch.tensor([1, 2, 3, 4, 5], dtype&#x3D;torch.float32)<br>  y &#x3D; torch.tensor([2, 4, 5, 4, 5], dtype&#x3D;torch.float32)<br>  ​  </p>
<h1 id="初始化权重和偏置"><a href="#初始化权重和偏置" class="headerlink" title="初始化权重和偏置"></a>初始化权重和偏置</h1><p>  w &#x3D; torch.tensor(0.0, requires_grad&#x3D;True)<br>  b &#x3D; torch.tensor(0.0, requires_grad&#x3D;True)<br>  ​  </p>
<h1 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h1><p>  lr &#x3D; 0.01<br>  ​  </p>
<h1 id="迭代次数"><a href="#迭代次数" class="headerlink" title="迭代次数"></a>迭代次数</h1><p>  epochs &#x3D; 100<br>  ​<br>  for epoch in range(epochs):<br>      # 前向传播<br>      y_pred &#x3D; w * x + b<br>  ​<br>      # 计算损失<br>      loss &#x3D; torch.mean((y_pred - y)**2)<br>  ​<br>      # 反向传播 (自动计算梯度)<br>      loss.backward()<br>  ​<br>      # 更新权重和偏置 (使用梯度下降)<br>      with torch.no_grad():<br>          w -&#x3D; lr * w.grad<br>          b -&#x3D; lr * b.grad<br>  ​<br>          # 清空梯度 (重要！)<br>          w.grad.zero_()<br>          b.grad.zero_()<br>  ​<br>      if (epoch + 1) % 10 &#x3D;&#x3D; 0:<br>          print(f”Epoch {epoch+1}&#x2F;{epochs}, Loss: {loss.item():.4f}, w: {w.item():.4f}, b: {b.item():.4f}”)<br>  ​  </p>
<h1 id="最终的-w-和-b"><a href="#最终的-w-和-b" class="headerlink" title="最终的 w 和 b"></a>最终的 w 和 b</h1><p>  print(f”最终的 w: {w.item():.4f}, 最终的 b: {b.item():.4f}”)</p>
<p>  <strong>小批量梯度下降 (Mini-batch Gradient Descent):</strong></p>
<p>  import torch<br>  import numpy as np<br>  ​  </p>
<h1 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h1><p>  x &#x3D; torch.tensor([1, 2, 3, 4, 5], dtype&#x3D;torch.float32)<br>  y &#x3D; torch.tensor([2, 4, 5, 4, 5], dtype&#x3D;torch.float32)<br>  ​  </p>
<h1 id="初始化权重和偏置-1"><a href="#初始化权重和偏置-1" class="headerlink" title="初始化权重和偏置"></a>初始化权重和偏置</h1><p>  w &#x3D; torch.tensor(0.0, requires_grad&#x3D;True)<br>  b &#x3D; torch.tensor(0.0, requires_grad&#x3D;True)<br>  ​  </p>
<h1 id="学习率-1"><a href="#学习率-1" class="headerlink" title="学习率"></a>学习率</h1><p>  lr &#x3D; 0.01<br>  ​  </p>
<h1 id="批次大小"><a href="#批次大小" class="headerlink" title="批次大小"></a>批次大小</h1><p>  batch_size &#x3D; 2<br>  ​  </p>
<h1 id="迭代次数-1"><a href="#迭代次数-1" class="headerlink" title="迭代次数"></a>迭代次数</h1><p>  epochs &#x3D; 100<br>  ​<br>  for epoch in range(epochs):<br>      # 随机打乱数据<br>      indices &#x3D; np.arange(len(x))<br>      np.random.shuffle(indices)<br>      x_shuffled &#x3D; x[indices]<br>      y_shuffled &#x3D; y[indices]<br>  ​<br>      for i in range(0, len(x), batch_size):<br>          # 获取当前批次的数据<br>          x_batch &#x3D; x_shuffled[i:i+batch_size]<br>          y_batch &#x3D; y_shuffled[i:i+batch_size]<br>  ​<br>          # 前向传播<br>          y_pred &#x3D; w * x_batch + b<br>  ​<br>          # 计算损失<br>          loss &#x3D; torch.mean((y_pred - y_batch)**2)<br>  ​<br>          # 反向传播<br>          loss.backward()<br>  ​<br>          # 更新权重和偏置<br>          with torch.no_grad():<br>              w -&#x3D; lr * w.grad<br>              b -&#x3D; lr * b.grad<br>  ​<br>              # 清空梯度<br>              w.grad.zero_()<br>              b.grad.zero_()<br>  ​<br>      if (epoch + 1) % 10 &#x3D;&#x3D; 0:<br>          print(f”Epoch {epoch+1}&#x2F;{epochs}, Loss: {loss.item():.4f}, w: {w.item():.4f}, b: {b.item():.4f}”)<br>  ​  </p>
<h1 id="最终的-w-和-b-1"><a href="#最终的-w-和-b-1" class="headerlink" title="最终的 w 和 b"></a>最终的 w 和 b</h1><p>  print(f”最终的 w: {w.item():.4f}, 最终的 b: {b.item():.4f}”)</p>
<p>  <strong>随机梯度下降 (Stochastic Gradient Descent):</strong></p>
<p>     import torch<br>  import numpy as np<br>  ​  </p>
<h1 id="数据集-2"><a href="#数据集-2" class="headerlink" title="数据集"></a>数据集</h1><p>  x &#x3D; torch.tensor([1, 2, 3, 4, 5], dtype&#x3D;torch.float32)<br>  y &#x3D; torch.tensor([2, 4, 5, 4, 5], dtype&#x3D;torch.float32)<br>  ​  </p>
<h1 id="初始化权重和偏置-2"><a href="#初始化权重和偏置-2" class="headerlink" title="初始化权重和偏置"></a>初始化权重和偏置</h1><p>  w &#x3D; torch.tensor(0.0, requires_grad&#x3D;True)<br>  b &#x3D; torch.tensor(0.0, requires_grad&#x3D;True)<br>  ​  </p>
<h1 id="学习率-2"><a href="#学习率-2" class="headerlink" title="学习率"></a>学习率</h1><p>  lr &#x3D; 0.01<br>  ​  </p>
<h1 id="迭代次数-每个样本都迭代一次"><a href="#迭代次数-每个样本都迭代一次" class="headerlink" title="迭代次数 (每个样本都迭代一次)"></a>迭代次数 (每个样本都迭代一次)</h1><p>  epochs &#x3D; 100<br>  ​<br>  for epoch in range(epochs):<br>      for i in range(len(x)):<br>        # 获取当前样本<br>        x_sample &#x3D; x[i]<br>        y_sample &#x3D; y[i]<br>        #前向传播<br>        y_pred &#x3D; w* x_sample + b<br>  ​<br>        #计算损失<br>        loss &#x3D; (y_pred - y_sample)<em><em>2<br>  ​<br>        #反向传播<br>        loss.backward()<br>  ​<br>        #更新权重和偏置<br>        with torch.no_grad():<br>          w -&#x3D; lr</em> w.grad<br>          b -&#x3D; lr</em> b.grad<br>          #清空梯度<br>          w.grad.zero_()<br>          b.grad.zero_()<br>  ​<br>      if (epoch + 1) % 10 &#x3D;&#x3D; 0:<br>          print(f”Epoch {epoch+1}&#x2F;{epochs}, w: {w.item():.4f}, b: {b.item():.4f}”)<br>  ​<br>  print(f”最终的 w: {w.item():.4f}, 最终的 b: {b.item():.4f}”)<br>  ​</p>
</li>
</ul>
<p><strong>二级知识点 4.2：其他优化器 (Optimizers) ✨</strong></p>
<ul>
<li><p><strong>范例：</strong> 使用 PyTorch 内置的优化器 (Adam)。</p>
<p>  import torch<br>  import torch.nn as nn<br>  import torch.optim as optim<br>  ​  </p>
<h1 id="数据集-同上"><a href="#数据集-同上" class="headerlink" title="数据集 (同上)"></a>数据集 (同上)</h1><p>  x &#x3D; torch.tensor([1, 2, 3, 4, 5], dtype&#x3D;torch.float32)<br>  y &#x3D; torch.tensor([2, 4, 5, 4, 5], dtype&#x3D;torch.float32)<br>  ​  </p>
<h1 id="定义一个简单的线性模型"><a href="#定义一个简单的线性模型" class="headerlink" title="定义一个简单的线性模型"></a>定义一个简单的线性模型</h1><p>  class LinearRegression(nn.Module):<br>      def <strong>init</strong>(self):<br>          super().<strong>init</strong>()<br>          self.linear &#x3D; nn.Linear(1, 1)  # 输入维度为 1，输出维度为 1<br>  ​<br>      def forward(self, x):<br>          return self.linear(x)<br>  ​  </p>
<h1 id="创建模型实例"><a href="#创建模型实例" class="headerlink" title="创建模型实例"></a>创建模型实例</h1><p>  model &#x3D; LinearRegression()<br>  ​  </p>
<h1 id="定义优化器-Adam"><a href="#定义优化器-Adam" class="headerlink" title="定义优化器 (Adam)"></a>定义优化器 (Adam)</h1><p>  optimizer &#x3D; optim.Adam(model.parameters(), lr&#x3D;0.01)<br>  ​  </p>
<h1 id="迭代次数-2"><a href="#迭代次数-2" class="headerlink" title="迭代次数"></a>迭代次数</h1><p>  epochs &#x3D; 100<br>  ​<br>  for epoch in range(epochs):<br>      # 前向传播<br>      y_pred &#x3D; model(x.unsqueeze(1))  # unsqueeze(1) 将 x 从 [5] 变为 [5, 1]<br>  ​<br>      # 计算损失<br>      loss &#x3D; torch.mean((y_pred.squeeze() - y)**2)  # squeeze() 将 y_pred 从 [5, 1] 变为 [5]<br>  ​<br>      # 反向传播<br>      loss.backward()<br>  ​<br>      # 更新参数 (使用优化器)<br>      optimizer.step()<br>  ​<br>      # 清空梯度<br>      optimizer.zero_grad()<br>  ​<br>      if (epoch + 1) % 10 &#x3D;&#x3D; 0:<br>          print(f”Epoch {epoch+1}&#x2F;{epochs}, Loss: {loss.item():.4f}, w: {model.linear.weight.item():.4f}, b: {model.linear.bias.item():.4f}”)<br>  ​  </p>
<h1 id="最终的-w-和-b-2"><a href="#最终的-w-和-b-2" class="headerlink" title="最终的 w 和 b"></a>最终的 w 和 b</h1><p>  print(f”最终的 w: {model.linear.weight.item():.4f}, 最终的 b: {model.linear.bias.item():.4f}”)</p>
</li>
</ul>
<p>通过这些范例和代码，你应该对梯度下降的不同变体以及如何使用 PyTorch 内置的优化器有了更深入的理解。请注意，实际应用中，我们通常会使用 PyTorch 提供的 <code>nn.Module</code>、<code>nn.Linear</code>、<code>optim</code> 等模块来构建模型和优化器，而不需要手动实现梯度下降的细节。</p>
<p>在下一阶段，我们将学习损失函数, 这是反向传播的”指挥官”！👨‍✈️</p>
<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>好的！让我们进入下一个关键环节：损失函数！🎯</p>
<p><strong>一级知识点 5：损失函数 (Loss Functions) 📉</strong></p>
<p>损失函数是神经网络训练的“指挥官”，它告诉神经网络当前的表现如何，以及距离“完美”还有多远。</p>
<ul>
<li><p><strong>二级知识点 5.1：损失函数的定义 📝</strong></p>
<ul>
<li><p>损失函数是一个衡量模型预测输出与真实标签之间差异的函数。</p>
</li>
<li><p>损失函数的值越小，表示模型的预测结果越接近真实标签，模型的性能越好。</p>
</li>
<li><p>损失函数的选择取决于具体的任务类型（例如分类、回归等）。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 5.2：不同任务的损失函数 ➗➖➕</strong></p>
<ul>
<li><p><strong>三级知识点 5.2.1：分类任务 (Classification) 🐱🐶</strong></p>
<ul>
<li><p><strong>交叉熵损失 (Cross-Entropy Loss):</strong> 用于多分类问题，衡量预测概率分布与真实标签分布之间的差异。</p>
<ul>
<li><p><strong>公式 (二分类):</strong> <code>- (y_true * log(y_pred) + (1 - y_true) * log(1 - y_pred))</code></p>
<ul>
<li><p><code>y_true</code>: 真实标签 (0 或 1)</p>
</li>
<li><p><code>y_pred</code>: 预测概率 (0-1 之间)</p>
</li>
</ul>
</li>
<li><p><strong>公式 (多分类):</strong> <code>- Σ(y_true_i * log(y_pred_i))</code></p>
<ul>
<li><p><code>y_true_i</code>: 真实标签的 one-hot 编码的第 i 个元素</p>
</li>
<li><p><code>y_pred_i</code>: 预测概率分布的第 i 个元素</p>
</li>
</ul>
</li>
<li><p><strong>PyTorch:</strong> <code>torch.nn.CrossEntropyLoss()</code> (多分类，内部会自动计算 Softmax) 或 <code>torch.nn.BCELoss()</code> (二分类，需要手动计算 Sigmoid)</p>
</li>
</ul>
</li>
<li><p><strong>Hinge Loss:</strong> 常用于支持向量机 (SVM)，目标是最大化分类边界。</p>
<ul>
<li><strong>PyTorch:</strong> <code>torch.nn.HingeEmbeddingLoss()</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>三级知识点 5.2.2：回归任务 (Regression) 🏠📈</strong></p>
<ul>
<li><p><strong>均方误差 (Mean Squared Error, MSE):</strong> 计算预测值与真实值之间差的平方的平均值。</p>
<ul>
<li><p><strong>公式:</strong> <code>(1/n) * Σ(y_pred - y_true)^2</code></p>
</li>
<li><p><strong>PyTorch:</strong> <code>torch.nn.MSELoss()</code></p>
</li>
</ul>
</li>
<li><p><strong>平均绝对误差 (Mean Absolute Error, MAE):</strong> 计算预测值与真实值之间差的绝对值的平均值。</p>
<ul>
<li><p><strong>公式:</strong> <code>(1/n) * Σ|y_pred - y_true|</code></p>
</li>
<li><p><strong>PyTorch:</strong> <code>torch.nn.L1Loss()</code></p>
</li>
</ul>
</li>
<li><p><strong>Huber Loss:</strong> MSE 和 MAE 的结合，对异常值更鲁棒。</p>
<ul>
<li><strong>PyTorch:</strong> <code>torch.nn.SmoothL1Loss()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>形象比喻:</strong></p>
<ul>
<li><p><strong>分类任务:</strong> 想象你在玩一个“猜动物”的游戏。</p>
<ul>
<li><strong>交叉熵损失:</strong> 就像猜错的“惩罚”，猜得越离谱，“惩罚”越大。</li>
</ul>
</li>
<li><p><strong>回归任务:</strong> 想象你在玩一个“扔飞镖”的游戏。</p>
<ul>
<li><p><strong>MSE:</strong> 就像计算所有飞镖偏离靶心的距离的平方的平均值。</p>
</li>
<li><p><strong>MAE:</strong> 就像计算所有飞镖偏离靶心的距离的平均值。</p>
</li>
</ul>
</li>
</ul>
<p>损失函数为神经网络提供了学习的目标，反向传播算法利用损失函数的梯度来更新网络参数，优化算法则负责具体的更新过程。</p>
<p>现在，你已经了解了损失函数的作用和常见类型。请思考：</p>
<ul>
<li><p>你能用自己的话解释损失函数的作用吗？</p>
</li>
<li><p>对于分类任务和回归任务，分别应该选择什么样的损失函数？</p>
</li>
</ul>
<h2 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h2><p>好的，让我们通过一些具体的例子来加深对损失函数的理解，并结合 PyTorch 代码进行演示。</p>
<p><strong>二级知识点 5.1：损失函数的定义 📝</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们正在训练一个模型来预测房价。</p>
<ul>
<li><p><strong>模型输出:</strong> 模型的预测房价 (例如：350,000 美元)</p>
</li>
<li><p><strong>真实标签:</strong> 房屋的实际价格 (例如：380,000 美元)</p>
</li>
<li><p><strong>损失函数:</strong> 我们可以使用均方误差 (MSE) 来衡量模型预测的准确性。</p>
<ul>
<li><strong>计算:</strong> <code>(350,000 - 380,000)^2 = 900,000,000</code> (这里为了简化，我们只计算了一个样本的损失)</li>
</ul>
</li>
</ul>
<p>  这个例子中，损失函数的值 (900,000,000) 越大，表示模型的预测结果与真实价格之间的差距越大，模型的性能越差。</p>
</li>
</ul>
<p><strong>二级知识点 5.2：不同任务的损失函数 ➗➖➕</strong></p>
<ul>
<li><p><strong>三级知识点 5.2.1：分类任务 (Classification) 🐱🐶</strong></p>
<ul>
<li><p><strong>范例：</strong> 我们要构建一个图像分类器，将图像分为猫或狗两类。</p>
<ul>
<li><p><strong>模型输出:</strong> 模型输出一个包含两个元素的向量，分别表示图像是猫和狗的概率。例如：<code>[0.8, 0.2]</code> (表示模型认为这张图片是猫的概率为 80%，是狗的概率为 20%)</p>
</li>
<li><p><strong>真实标签:</strong></p>
<ul>
<li><p>如果图片是猫，则真实标签为 <code>[1, 0]</code> (one-hot 编码)</p>
</li>
<li><p>如果图片是狗，则真实标签为 <code>[0, 1]</code> (one-hot 编码)</p>
</li>
</ul>
</li>
<li><p><strong>损失函数:</strong> 我们可以使用交叉熵损失 (Cross-Entropy Loss)。</p>
</li>
</ul>
<p>  <strong>PyTorch 代码 (二分类):</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="模型输出-假设模型已经输出了预测概率"><a href="#模型输出-假设模型已经输出了预测概率" class="headerlink" title="模型输出 (假设模型已经输出了预测概率)"></a>模型输出 (假设模型已经输出了预测概率)</h1><p>  y_pred &#x3D; torch.tensor([0.8, 0.2])  # 预测为猫的概率为 0.8，狗的概率为 0.2<br>  y_pred &#x3D; torch.sigmoid(y_pred) # 需要手动计算 Sigmoid<br>  ​  </p>
<h1 id="真实标签-假设这张图片是猫"><a href="#真实标签-假设这张图片是猫" class="headerlink" title="真实标签 (假设这张图片是猫)"></a>真实标签 (假设这张图片是猫)</h1><p>  y_true &#x3D; torch.tensor([1.0, 0.0])  # one-hot 编码<br>  ​  </p>
<h1 id="计算二元交叉熵损失-Binary-Cross-Entropy-Loss"><a href="#计算二元交叉熵损失-Binary-Cross-Entropy-Loss" class="headerlink" title="计算二元交叉熵损失 (Binary Cross-Entropy Loss)"></a>计算二元交叉熵损失 (Binary Cross-Entropy Loss)</h1><p>  bce_loss &#x3D; nn.BCELoss()<br>  loss &#x3D; bce_loss(y_pred, y_true)<br>  ​<br>  print(f”二元交叉熵损失: {loss.item():.4f}”)</p>
<p>  <strong>PyTorch 代码 (多分类):</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="模型输出-假设模型已经输出了预测概率-1"><a href="#模型输出-假设模型已经输出了预测概率-1" class="headerlink" title="模型输出 (假设模型已经输出了预测概率)"></a>模型输出 (假设模型已经输出了预测概率)</h1><p>  y_pred &#x3D; torch.tensor([[0.8, 0.2], [0.3, 0.7]])  # 两张图片，第一张预测为猫的概率高，第二张预测为狗的概率高<br>  #y_pred &#x3D; torch.softmax(y_pred, dim&#x3D;1)  # nn.CrossEntropyLoss 已经包含了 softmax，所以这里不需要<br>  ​  </p>
<h1 id="真实标签-假设第一张图片是猫，第二张图片是狗"><a href="#真实标签-假设第一张图片是猫，第二张图片是狗" class="headerlink" title="真实标签 (假设第一张图片是猫，第二张图片是狗)"></a>真实标签 (假设第一张图片是猫，第二张图片是狗)</h1><p>  y_true &#x3D; torch.tensor([0, 1])  # 类别索引<br>  ​  </p>
<h1 id="计算交叉熵损失-Cross-Entropy-Loss"><a href="#计算交叉熵损失-Cross-Entropy-Loss" class="headerlink" title="计算交叉熵损失 (Cross-Entropy Loss)"></a>计算交叉熵损失 (Cross-Entropy Loss)</h1><p>  ce_loss &#x3D; nn.CrossEntropyLoss()<br>  loss &#x3D; ce_loss(y_pred, y_true)<br>  ​<br>  print(f”交叉熵损失: {loss.item():.4f}”)</p>
</li>
</ul>
</li>
<li><p><strong>三级知识点 5.2.2：回归任务 (Regression) 🏠📈</strong></p>
<ul>
<li><p><strong>范例：</strong> 我们要构建一个模型来预测房价 (与之前的例子相同)。</p>
<ul>
<li><p><strong>模型输出:</strong> 模型预测的房价 (例如：350,000 美元)</p>
</li>
<li><p><strong>真实标签:</strong> 房屋的实际价格 (例如：380,000 美元)</p>
</li>
<li><p><strong>损失函数:</strong></p>
<ul>
<li><p><strong>均方误差 (MSE):</strong> <code>(350,000 - 380,000)^2 = 900,000,000</code></p>
</li>
<li><p><strong>平均绝对误差 (MAE):</strong> <code>|350,000 - 380,000| = 30,000</code></p>
</li>
</ul>
</li>
</ul>
<p>  <strong>PyTorch 代码 (MSE):</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="模型输出-假设模型已经输出了预测值"><a href="#模型输出-假设模型已经输出了预测值" class="headerlink" title="模型输出 (假设模型已经输出了预测值)"></a>模型输出 (假设模型已经输出了预测值)</h1><p>  y_pred &#x3D; torch.tensor([350000.0])<br>  ​  </p>
<h1 id="真实标签"><a href="#真实标签" class="headerlink" title="真实标签"></a>真实标签</h1><p>  y_true &#x3D; torch.tensor([380000.0])<br>  ​  </p>
<h1 id="计算均方误差-MSE"><a href="#计算均方误差-MSE" class="headerlink" title="计算均方误差 (MSE)"></a>计算均方误差 (MSE)</h1><p>  mse_loss &#x3D; nn.MSELoss()<br>  loss &#x3D; mse_loss(y_pred, y_true)<br>  ​<br>  print(f”均方误差: {loss.item():.4f}”)</p>
<p>  <strong>PyTorch 代码 (MAE):</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="模型输出-假设模型已经输出了预测值-1"><a href="#模型输出-假设模型已经输出了预测值-1" class="headerlink" title="模型输出 (假设模型已经输出了预测值)"></a>模型输出 (假设模型已经输出了预测值)</h1><p>  y_pred &#x3D; torch.tensor([350000.0])<br>  ​  </p>
<h1 id="真实标签-1"><a href="#真实标签-1" class="headerlink" title="真实标签"></a>真实标签</h1><p>  y_true &#x3D; torch.tensor([380000.0])<br>  ​  </p>
<h1 id="计算平均绝对误差-MAE"><a href="#计算平均绝对误差-MAE" class="headerlink" title="计算平均绝对误差 (MAE)"></a>计算平均绝对误差 (MAE)</h1><p>  mae_loss &#x3D; nn.L1Loss()<br>  loss &#x3D; mae_loss(y_pred, y_true)<br>  ​<br>  print(f”平均绝对误差: {loss.item():.4f}”)</p>
</li>
</ul>
</li>
</ul>
<p>通过这些范例和代码，你可以看到不同类型的损失函数是如何计算的，以及如何在 PyTorch 中使用它们。在实际应用中，你需要根据你的任务类型选择合适的损失函数。</p>
<p>在下一阶段，我们将学习反向传播的一些实际应用！🌟</p>
<h1 id="实际应用（一小部分）"><a href="#实际应用（一小部分）" class="headerlink" title="实际应用（一小部分）"></a>实际应用（一小部分）</h1><p>太好了！接下来，让我们一起探索反向传播在现实世界中的应用，看看它如何大显身手！🌟</p>
<p><strong>一级知识点 6：反向传播的应用 🌍</strong></p>
<p>反向传播算法不仅仅是理论上的概念，它已经在许多领域取得了显著的成果。</p>
<ul>
<li><p><strong>二级知识点 6.1：人脸识别 (Face Recognition) 👤📸</strong></p>
<ul>
<li><p><strong>原理:</strong> 卷积神经网络 (CNN) 结合反向传播算法，可以学习人脸图像的特征，从而实现人脸识别。</p>
</li>
<li><p><strong>过程:</strong></p>
<ol>
<li><p><strong>数据收集:</strong> 收集大量人脸图像，并标注每个图像对应的人物身份。</p>
</li>
<li><p><strong>构建 CNN 模型:</strong> 设计一个 CNN 模型，通常包含多个卷积层、池化层和全连接层。</p>
</li>
<li><p><strong>前向传播:</strong> 将人脸图像输入到 CNN 模型中，进行前向传播，得到模型的预测输出（例如，属于每个人物身份的概率）。</p>
</li>
<li><p><strong>计算损失:</strong> 使用交叉熵损失函数等，计算模型预测输出与真实标签之间的差异。</p>
</li>
<li><p><strong>反向传播:</strong> 使用反向传播算法，计算损失函数相对于模型中每个权重和偏置的梯度。</p>
</li>
<li><p><strong>更新参数:</strong> 使用优化算法（例如 Adam），根据计算出的梯度更新模型的权重和偏置。</p>
</li>
<li><p><strong>重复步骤 3-6:</strong> 不断迭代，直到模型收敛或达到预定的训练轮数。</p>
</li>
</ol>
</li>
<li><p><strong>应用:</strong> 手机解锁、门禁系统、安防监控等。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 6.2：自然语言处理：语音识别 (NLP: Speech Recognition) 🗣️📱</strong></p>
<ul>
<li><p><strong>原理:</strong> 循环神经网络 (RNN) 或 Transformer 模型结合反向传播算法，可以将语音信号转换为文本。</p>
</li>
<li><p><strong>过程:</strong></p>
<ol>
<li><p><strong>数据收集:</strong> 收集大量语音数据，并标注每个语音片段对应的文本内容。</p>
</li>
<li><p><strong>构建模型:</strong> 设计一个 RNN 或 Transformer 模型。</p>
</li>
<li><p><strong>特征提取:</strong> 将语音信号转换为声学特征（例如梅尔频率倒谱系数 MFCC）。</p>
</li>
<li><p><strong>前向传播:</strong> 将声学特征输入到模型中，进行前向传播，得到模型的预测输出（例如，每个时间步的文本预测概率）。</p>
</li>
<li><p><strong>计算损失:</strong> 使用交叉熵损失函数等，计算模型预测输出与真实标签之间的差异。</p>
</li>
<li><p><strong>反向传播:</strong> 使用反向传播算法（例如 BPTT，随时间反向传播），计算损失函数相对于模型中每个权重和偏置的梯度。</p>
</li>
<li><p><strong>更新参数:</strong> 使用优化算法（例如 Adam），根据计算出的梯度更新模型的权重和偏置。</p>
</li>
<li><p><strong>重复步骤 4-7:</strong> 不断迭代，直到模型收敛或达到预定的训练轮数。</p>
</li>
</ol>
</li>
<li><p><strong>应用:</strong> 语音助手（如 Siri、Alexa）、语音输入法、实时字幕等。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 6.3： 事故预防</strong></p>
<ul>
<li><p><strong>原理:</strong> 利用反向传播算法训练的模型能够预测潜在的危险情况，从而采取预防措施，减少事故发生的可能性。</p>
</li>
<li><p><strong>应用</strong>: 通过分析数据来预测矿井事故， 提前采取措施。</p>
</li>
</ul>
</li>
</ul>
<p>反向传播的应用远不止这些，它还广泛应用于图像生成、机器翻译、推荐系统、自动驾驶、医疗诊断、金融预测等众多领域。随着深度学习技术的不断发展，反向传播算法将在更多领域发挥重要作用。</p>
<p>现在，你已经了解了反向传播的一些实际应用。请思考：</p>
<ul>
<li><p>你能举出其他一些反向传播的应用例子吗？</p>
</li>
<li><p>你认为反向传播算法在未来还可能有哪些应用？</p>
</li>
</ul>
<h2 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h2><p>好的，让我们通过一些具体的例子和代码片段，来展示反向传播在实际应用中的强大功能。</p>
<p><strong>一级知识点 6：反向传播的应用 🌍</strong></p>
<p><strong>二级知识点 6.1：人脸识别 (Face Recognition) 👤📸</strong></p>
<ul>
<li><p><strong>范例：</strong> 使用 PyTorch 和预训练的 CNN 模型 (例如 FaceNet) 进行人脸识别。</p>
<p>  import torch<br>  import torchvision<br>  from torchvision import transforms<br>  from PIL import Image  </p>
<h1 id="加载预训练的-FaceNet-模型-这里使用-torchvision-提供的-resnet18-作为示例"><a href="#加载预训练的-FaceNet-模型-这里使用-torchvision-提供的-resnet18-作为示例" class="headerlink" title="加载预训练的 FaceNet 模型 (这里使用 torchvision 提供的 resnet18 作为示例)"></a>加载预训练的 FaceNet 模型 (这里使用 torchvision 提供的 resnet18 作为示例)</h1><h1 id="实际应用中，你可能需要下载并加载更专业的-FaceNet-模型"><a href="#实际应用中，你可能需要下载并加载更专业的-FaceNet-模型" class="headerlink" title="实际应用中，你可能需要下载并加载更专业的 FaceNet 模型"></a>实际应用中，你可能需要下载并加载更专业的 FaceNet 模型</h1><p>  model &#x3D; torchvision.models.resnet18(pretrained&#x3D;True)<br>  model.fc &#x3D; torch.nn.Linear(512, 128)  # 修改最后一层，输出 128 维的特征向量<br>  model.eval()  # 设置为评估模式  </p>
<h1 id="定义图像预处理步骤"><a href="#定义图像预处理步骤" class="headerlink" title="定义图像预处理步骤"></a>定义图像预处理步骤</h1><p>  transform &#x3D; transforms.Compose([<br>  transforms.Resize((160, 160)),  # 调整图像大小<br>  transforms.ToTensor(),  # 转换为 Tensor<br>  transforms.Normalize(mean&#x3D;[0.485, 0.456, 0.406], std&#x3D;[0.229, 0.224, 0.225])  # 标准化<br>  ])  </p>
<h1 id="加载两张人脸图像-例如，image1-jpg-和-image2-jpg"><a href="#加载两张人脸图像-例如，image1-jpg-和-image2-jpg" class="headerlink" title="加载两张人脸图像 (例如，image1.jpg 和 image2.jpg)"></a>加载两张人脸图像 (例如，image1.jpg 和 image2.jpg)</h1><p>  image1 &#x3D; Image.open(“image1.jpg”)<br>  image2 &#x3D; Image.open(“image2.jpg”)  </p>
<h1 id="对图像进行预处理"><a href="#对图像进行预处理" class="headerlink" title="对图像进行预处理"></a>对图像进行预处理</h1><p>  image1_tensor &#x3D; transform(image1)<br>  image2_tensor &#x3D; transform(image2)  </p>
<h1 id="将图像输入到模型中，获取特征向量"><a href="#将图像输入到模型中，获取特征向量" class="headerlink" title="将图像输入到模型中，获取特征向量"></a>将图像输入到模型中，获取特征向量</h1><p>  with torch.no_grad():<br>  feature_vector1 &#x3D; model(image1_tensor.unsqueeze(0))  # unsqueeze(0) 增加批次维度<br>  feature_vector2 &#x3D; model(image2_tensor.unsqueeze(0))  </p>
<h1 id="计算两个特征向量之间的距离-例如，欧氏距离"><a href="#计算两个特征向量之间的距离-例如，欧氏距离" class="headerlink" title="计算两个特征向量之间的距离 (例如，欧氏距离)"></a>计算两个特征向量之间的距离 (例如，欧氏距离)</h1><p>  distance &#x3D; torch.norm(feature_vector1 - feature_vector2)  </p>
<h1 id="设置一个阈值，判断两张图片是否属于同一个人"><a href="#设置一个阈值，判断两张图片是否属于同一个人" class="headerlink" title="设置一个阈值，判断两张图片是否属于同一个人"></a>设置一个阈值，判断两张图片是否属于同一个人</h1><p>  threshold &#x3D; 1.0  # 这个阈值需要根据实际情况调整  </p>
<p>  if distance &lt; threshold:<br>  print(“这两张图片可能是同一个人。”)<br>  else:<br>  print(“这两张图片可能不是同一个人。”)<br>  print(f”两张图片特征向量之间的距离: {distance.item():.4f}”)</p>
<p>  <strong>代码解释:</strong></p>
<ol>
<li><p><strong>加载预训练模型:</strong> 我们使用 <code>torchvision</code> 提供的预训练 <code>resnet18</code> 模型作为示例。实际应用中，你可能需要下载并加载更专业的 FaceNet 模型，例如在 VGGFace2 数据集上预训练的模型。</p>
</li>
<li><p><strong>修改最后一层:</strong> 我们将 <code>resnet18</code> 模型的最后一层 (全连接层) 修改为输出 128 维的特征向量。这是 FaceNet 模型常用的特征向量维度。</p>
</li>
<li><p><strong>图像预处理:</strong> 我们定义了一系列图像预处理步骤，包括调整图像大小、转换为 Tensor 和标准化。这些步骤对于提高模型的性能非常重要。</p>
</li>
<li><p><strong>特征提取:</strong> 我们将预处理后的图像输入到模型中，获取 128 维的特征向量。</p>
</li>
<li><p><strong>距离计算:</strong> 我们计算两个特征向量之间的欧氏距离。距离越小，表示两张人脸图像越相似。</p>
</li>
<li><p><strong>阈值判断:</strong> 我们设置一个阈值，如果距离小于阈值，则认为两张图片属于同一个人。</p>
</li>
</ol>
</li>
</ul>
<p><strong>二级知识点 6.2：自然语言处理：语音识别 (NLP: Speech Recognition) 🗣️📱</strong></p>
<ul>
<li><p><strong>范例：</strong> 使用 PyTorch 和预训练的语音识别模型 (例如 Wav2Vec2) 进行语音识别。由于从头训练一个语音识别模型非常复杂，并且需要大量的计算资源，一般情况下我们都会使用预训练模型</p>
<p>  import torch<br>  from transformers import Wav2Vec2ForCTC, Wav2Vec2Processor<br>  ​  </p>
<h1 id="加载预训练的-Wav2Vec2-模型和处理器"><a href="#加载预训练的-Wav2Vec2-模型和处理器" class="headerlink" title="加载预训练的 Wav2Vec2 模型和处理器"></a>加载预训练的 Wav2Vec2 模型和处理器</h1><p>  processor &#x3D; Wav2Vec2Processor.from_pretrained(“facebook&#x2F;wav2vec2-base-960h”)<br>  model &#x3D; Wav2Vec2ForCTC.from_pretrained(“facebook&#x2F;wav2vec2-base-960h”)<br>  model.eval()  # 设置为评估模式<br>  ​  </p>
<h1 id="加载音频文件-例如，audio-wav，需要是单声道、16kHz-采样率的音频"><a href="#加载音频文件-例如，audio-wav，需要是单声道、16kHz-采样率的音频" class="headerlink" title="加载音频文件 (例如，audio.wav，需要是单声道、16kHz 采样率的音频)"></a>加载音频文件 (例如，audio.wav，需要是单声道、16kHz 采样率的音频)</h1><h1 id="这里我们使用-torchaudio-来加载音频，你需要先安装-torchaudio：pip-install-torchaudio"><a href="#这里我们使用-torchaudio-来加载音频，你需要先安装-torchaudio：pip-install-torchaudio" class="headerlink" title="这里我们使用 torchaudio 来加载音频，你需要先安装 torchaudio：pip install torchaudio"></a>这里我们使用 torchaudio 来加载音频，你需要先安装 torchaudio：pip install torchaudio</h1><p>  import torchaudio<br>  waveform, sample_rate &#x3D; torchaudio.load(“audio.wav”)<br>  ​  </p>
<h1 id="如果音频不是-16kHz-采样率，进行重采样"><a href="#如果音频不是-16kHz-采样率，进行重采样" class="headerlink" title="如果音频不是 16kHz 采样率，进行重采样"></a>如果音频不是 16kHz 采样率，进行重采样</h1><p>  if sample_rate !&#x3D; 16000:<br>      waveform &#x3D; torchaudio.functional.resample(waveform, sample_rate, 16000)<br>  ​  </p>
<h1 id="将音频数据转换为模型所需的输入格式"><a href="#将音频数据转换为模型所需的输入格式" class="headerlink" title="将音频数据转换为模型所需的输入格式"></a>将音频数据转换为模型所需的输入格式</h1><p>  input_values &#x3D; processor(waveform, return_tensors&#x3D;”pt”, padding&#x3D;”longest”).input_values<br>  ​  </p>
<h1 id="将音频数据输入到模型中，获取-logits"><a href="#将音频数据输入到模型中，获取-logits" class="headerlink" title="将音频数据输入到模型中，获取 logits"></a>将音频数据输入到模型中，获取 logits</h1><p>  with torch.no_grad():<br>      logits &#x3D; model(input_values).logits<br>  ​  </p>
<h1 id="对-logits-进行解码，获取预测的文本"><a href="#对-logits-进行解码，获取预测的文本" class="headerlink" title="对 logits 进行解码，获取预测的文本"></a>对 logits 进行解码，获取预测的文本</h1><p>  predicted_ids &#x3D; torch.argmax(logits, dim&#x3D;-1)<br>  transcription &#x3D; processor.batch_decode(predicted_ids)[0]<br>  ​<br>  print(f”语音识别结果: {transcription}”)</p>
<p>  <strong>代码解释:</strong></p>
<ol>
<li><p><strong>加载预训练模型和处理器:</strong> 我们使用 Hugging Face Transformers 库提供的 <code>Wav2Vec2ForCTC</code> 和 <code>Wav2Vec2Processor</code>。<code>Wav2Vec2ForCTC</code> 是一个预训练的语音识别模型，<code>Wav2Vec2Processor</code> 用于将音频数据转换为模型所需的输入格式。</p>
</li>
<li><p><strong>加载音频文件:</strong> 我们使用 <code>torchaudio</code> 库加载音频文件。你需要确保音频文件是单声道、16kHz 采样率的。如果不是，需要进行重采样。</p>
</li>
<li><p><strong>数据预处理:</strong> 我们使用 <code>processor</code> 将音频数据转换为模型所需的输入格式。</p>
</li>
<li><p><strong>模型预测:</strong> 我们将预处理后的音频数据输入到模型中，获取 <code>logits</code>。<code>logits</code> 是模型输出的原始值，还没有经过 Softmax 转换。</p>
</li>
<li><p><strong>解码:</strong> 我们使用 <code>torch.argmax</code> 对 <code>logits</code> 进行解码，获取预测的文本 ID。然后，我们使用 <code>processor.batch_decode</code> 将文本 ID 转换为文本。</p>
</li>
</ol>
</li>
</ul>
<p>这些范例展示了反向传播在人脸识别和语音识别中的应用。请注意，这些只是简化的示例，实际应用中可能需要更复杂的模型、更多的数据预处理步骤以及更精细的调参。</p>
<h1 id="反向传播📣的历史"><a href="#反向传播📣的历史" class="headerlink" title="反向传播📣的历史"></a>反向传播📣的历史</h1><p>说到这里，那就顺带看看，一起回顾反向传播算法的发展历程，了解这段精彩的历史！📜</p>
<p><strong>一级知识点 7：反向传播的历史 🕰️</strong></p>
<p>反向传播算法并非一蹴而就，它的发展历经了数十年的时间，凝聚了许多研究者的智慧和努力。</p>
<ul>
<li><p><strong>19 世纪：梯度下降法的雏形 📉</strong></p>
<ul>
<li><strong>Baron Augustin-Louis Cauchy (法国数学家):</strong> 提出了梯度下降法 (Gradient Descent) 的思想，用于解决复杂的数学问题。这为反向传播算法奠定了基础。</li>
</ul>
</li>
<li><p><strong>1970 年：反向传播的早期探索 🌱</strong></p>
<ul>
<li><strong>Seppo Linnainmaa (芬兰硕士生):</strong> 提出了一种用于稀疏连接网络的误差反向传播算法。虽然他没有明确提到神经网络，但他的工作为反向传播算法的提出奠定了基础。</li>
</ul>
</li>
<li><p><strong>20 世纪 80 年代：反向传播的突破 🚀</strong></p>
<ul>
<li><p><strong>多位研究者独立研究:</strong> 独立开发了时间反向传播 (Backpropagation Through Time, BPTT) 算法，用于训练循环神经网络 (RNN)。</p>
</li>
<li><p><strong>1986 年：David Rumelhart 及其同事:</strong> 发表了一篇具有里程碑意义的论文，将 Linnainmaa 的反向传播算法应用于多层神经网络，并证明了其有效性。这篇论文被认为是反向传播算法的正式提出，极大地推动了神经网络的发展。</p>
</li>
<li><p><strong>1989 年：Yann LeCun:</strong> 将反向传播算法应用于卷积神经网络 (CNN)，用于手写数字识别，取得了显著的成果。</p>
</li>
</ul>
</li>
<li><p><strong>21 世纪：反向传播的广泛应用和发展 🌐</strong></p>
<ul>
<li><p>随着深度学习的兴起，反向传播算法成为训练各种类型神经网络的核心算法。</p>
</li>
<li><p>研究者们不断对反向传播算法进行改进和优化，例如：</p>
<ul>
<li><p><strong>并行化计算:</strong> 利用 GPU 等硬件加速反向传播的计算速度。</p>
</li>
<li><p><strong>优化算法:</strong> 提出各种新的优化算法（如 Adam、RMSprop 等），以提高训练效率和模型性能。</p>
</li>
<li><p><strong>梯度消失&#x2F;爆炸问题:</strong> 提出各种解决方案（如 ReLU 激活函数、Batch Normalization、残差连接等），以缓解梯度消失&#x2F;爆炸问题。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>反向传播算法的发展历程是一个不断探索、不断创新的过程。正是由于这些研究者的努力，我们才能够利用深度学习技术解决各种复杂的问题。</p>
<p>现在，你已经了解了反向传播算法的历史。请思考：</p>
<ul>
<li><p>反向传播算法的发展历程中，有哪些关键的里程碑事件？</p>
</li>
<li><p>反向传播算法的提出对神经网络的发展产生了什么影响？</p>
</li>
</ul>
<p>我们还剩下最后一个知识点了：超参数！</p>
<h1 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h1><p>好的！让我们来了解神经网络中的“神秘”参数——超参数！🧙‍♂️</p>
<p><strong>一级知识点 8：超参数 (Hyperparameters) ⚙️</strong></p>
<p>超参数是神经网络中非常重要的概念。它们不是通过训练数据学习得到的，而是在训练之前由人工设置的参数。超参数的选择对模型的性能有很大的影响。</p>
<ul>
<li><p><strong>二级知识点 8.1：输入图像大小 (Input Image Size) 🖼️</strong></p>
<ul>
<li><p><strong>定义:</strong> 输入到神经网络的图像的尺寸（宽度和高度）。</p>
</li>
<li><p><strong>影响:</strong></p>
<ul>
<li><p>较大的图像通常包含更多的细节信息，可能有助于提高模型的性能，但也会增加计算量和内存消耗。</p>
</li>
<li><p>较小的图像计算量较小，训练速度更快，但可能会丢失一些细节信息。</p>
</li>
</ul>
</li>
<li><p><strong>选择:</strong> 需要根据具体的任务和数据集进行权衡。通常需要进行实验来确定最佳的输入图像大小。</p>
</li>
<li><p><strong>示例:</strong> 对于 ImageNet 数据集，常用的输入图像大小为 224x224 或 299x299。对于 MNIST 数据集，输入图像大小为 28x28。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.2：学习率 (Learning Rate) 🏃</strong></p>
<ul>
<li><p><strong>定义:</strong> 控制权重更新的步长。</p>
</li>
<li><p><strong>影响:</strong></p>
<ul>
<li><p>学习率过大可能导致模型在最小值附近震荡，甚至无法收敛。</p>
</li>
<li><p>学习率过小可能导致模型收敛速度过慢，需要更长的训练时间。</p>
</li>
</ul>
</li>
<li><p><strong>选择:</strong> 通常需要通过实验来确定最佳的学习率。可以使用学习率衰减策略，在训练过程中逐渐减小学习率。</p>
</li>
<li><p><strong>示例:</strong> 常用的学习率范围为 0.1 到 0.0001。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.3：正则化参数 (Regularization Parameter) 🏋️</strong></p>
<ul>
<li><p><strong>定义:</strong> 用于控制模型复杂度，防止过拟合。</p>
</li>
<li><p><strong>影响:</strong></p>
<ul>
<li><p>正则化参数越大，对模型复杂度的惩罚越大，模型越倾向于选择更简单的模型。</p>
</li>
<li><p>正则化参数越小，对模型复杂度的惩罚越小，模型可能更容易过拟合。</p>
</li>
</ul>
</li>
<li><p><strong>选择:</strong> 需要根据具体的任务和数据集进行权衡。通常需要进行实验来确定最佳的正则化参数。</p>
</li>
<li><p><strong>示例:</strong> 常用的正则化方法包括 L1 正则化和 L2 正则化。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.4：神经网络层数 (Number of Layers) 🧱</strong></p>
<ul>
<li><p><strong>定义:</strong> 神经网络中隐藏层的数量。</p>
</li>
<li><p><strong>影响:</strong></p>
<ul>
<li><p>层数越多，模型的表示能力越强，但也越容易过拟合。</p>
</li>
<li><p>层数越少，模型的表示能力越弱，可能无法很好地拟合数据。</p>
</li>
</ul>
</li>
<li><p><strong>选择:</strong> 需要根据具体的任务和数据集进行权衡。通常需要进行实验来确定最佳的层数。</p>
</li>
<li><p><strong>示例:</strong> 对于简单的任务，可以使用较少的层数（例如 1-2 层）。对于复杂的任务，可能需要使用较多的层数（例如几十层甚至上百层）。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.5：批处理大小 (Batch Size) 📦</strong></p>
<ul>
<li><p><strong>定义:</strong> 每次迭代中使用的训练样本数量。</p>
</li>
<li><p><strong>影响:</strong></p>
<ul>
<li><p>批处理大小越大，梯度估计越准确，训练越稳定，但内存消耗越大，每次迭代的时间越长。</p>
</li>
<li><p>批处理大小越小，内存消耗越小，每次迭代的时间越短，但梯度估计可能不够准确，训练可能不稳定。</p>
</li>
</ul>
</li>
<li><p><strong>选择:</strong> 需要根据具体的硬件条件和数据集大小进行权衡。通常需要进行实验来确定最佳的批处理大小。</p>
</li>
<li><p><strong>示例:</strong> 常用的批处理大小范围为 32 到 1024。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.6：卷积层参数 (Convolutional Layer Parameters) 🧱</strong></p>
<ul>
<li><p><strong>卷积核大小 (Kernel Size):</strong> 卷积核的尺寸（例如 3x3、5x5）。</p>
</li>
<li><p><strong>步长 (Stride):</strong> 卷积核在图像上移动的步长（例如 1、2）。</p>
</li>
<li><p><strong>填充 (Padding):</strong> 在图像边缘填充像素的方式（例如 “valid”、“same”）。</p>
</li>
<li><p><strong>卷积核数量 (Number of Filters):</strong> 卷积层中卷积核的数量。</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.7：池化层参数 (Pooling Layer Parameters) 🧱</strong></p>
<ul>
<li><p><strong>池化核大小 (Kernel Size):</strong> 池化核的尺寸（例如 2x2、3x3）。</p>
</li>
<li><p><strong>步长 (Stride):</strong> 池化核移动的步长（例如 2、3）。</p>
</li>
<li><p><strong>池化类型</strong>: 最大池化， 均值池化等</p>
</li>
</ul>
</li>
<li><p><strong>二级知识点 8.8：迭代周期 (Epochs) 🔁</strong></p>
<ul>
<li><p><strong>定义:</strong> 将所有训练数据过一遍叫做一个周期。</p>
</li>
<li><p><strong>影响:</strong></p>
<ul>
<li><p>周期数越多， 模型训练时间越长， 容易过拟合。</p>
</li>
<li><p>周期数越少， 模型可能无法完全学习到数据中的规律</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="范例-5"><a href="#范例-5" class="headerlink" title="范例"></a>范例</h1><p>好的，我们来为超参数提供一些更具体的范例，并结合 PyTorch 代码进行说明。</p>
<p><strong>一级知识点 8：超参数 (Hyperparameters) ⚙️</strong></p>
<p><strong>二级知识点 8.1：输入图像大小 (Input Image Size) 🖼️</strong></p>
<ul>
<li><p><strong>范例：</strong> 假设我们要训练一个图像分类模型，使用 CIFAR-10 数据集。CIFAR-10 数据集中的图像大小为 32x32 像素。</p>
<ul>
<li><p><strong>情况 1：</strong> 我们将输入图像大小设置为 32x32（原始大小）。</p>
<ul>
<li><p><strong>优点:</strong> 不需要对图像进行额外的缩放操作，保留了原始图像的所有信息。</p>
</li>
<li><p><strong>缺点:</strong> 如果模型比较复杂，计算量可能会比较大。</p>
</li>
</ul>
</li>
<li><p><strong>情况 2：</strong> 我们将输入图像大小设置为 64x64。</p>
<ul>
<li><p><strong>优点:</strong> 可能会提高模型的性能（如果模型能够学习到更精细的特征）。</p>
</li>
<li><p><strong>缺点:</strong> 增加了计算量和内存消耗。需要对原始图像进行上采样操作，可能会引入一些噪声。</p>
</li>
</ul>
</li>
<li><p><strong>情况 3：</strong> 我们将输入图像大小设置为 16x16。</p>
<ul>
<li><p><strong>优点:</strong> 减少了计算量和内存消耗。</p>
</li>
<li><p><strong>缺点:</strong> 可能会降低模型的性能（丢失了一些细节信息）。需要对原始图像进行下采样操作，可能会导致信息损失。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>PyTorch 代码 (调整输入图像大小):</strong></p>
<p>  import torchvision.transforms as transforms<br>  ​  </p>
<h1 id="定义图像预处理步骤-1"><a href="#定义图像预处理步骤-1" class="headerlink" title="定义图像预处理步骤"></a>定义图像预处理步骤</h1><p>  transform &#x3D; transforms.Compose([<br>      transforms.Resize((64, 64)),  # 将图像大小调整为 64x64<br>      transforms.ToTensor(),<br>      transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))<br>  ])<br>  ​  </p>
<h1 id="加载-CIFAR-10-数据集，并应用预处理步骤"><a href="#加载-CIFAR-10-数据集，并应用预处理步骤" class="headerlink" title="加载 CIFAR-10 数据集，并应用预处理步骤"></a>加载 CIFAR-10 数据集，并应用预处理步骤</h1><p>  trainset &#x3D; torchvision.datasets.CIFAR10(root&#x3D;’.&#x2F;data’, train&#x3D;True,<br>                                          download&#x3D;True, transform&#x3D;transform)</p>
</li>
</ul>
<p><strong>二级知识点 8.2：学习率 (Learning Rate) 🏃</strong></p>
<ul>
<li><p><strong>范例：</strong> 我们使用 PyTorch 构建一个简单的线性回归模型。</p>
<p>  import torch<br>  import torch.nn as nn<br>  import torch.optim as optim<br>  ​  </p>
<h1 id="…-省略数据加载和模型定义部分，参考之前的线性回归例子-…"><a href="#…-省略数据加载和模型定义部分，参考之前的线性回归例子-…" class="headerlink" title="… (省略数据加载和模型定义部分，参考之前的线性回归例子) …"></a>… (省略数据加载和模型定义部分，参考之前的线性回归例子) …</h1><h1 id="定义一个简单的线性模型-1"><a href="#定义一个简单的线性模型-1" class="headerlink" title="定义一个简单的线性模型"></a>定义一个简单的线性模型</h1><p>  class LinearRegression(nn.Module):<br>      def <strong>init</strong>(self):<br>          super().<strong>init</strong>()<br>          self.linear &#x3D; nn.Linear(1, 1)  # 输入维度为 1，输出维度为 1<br>  ​<br>      def forward(self, x):<br>          return self.linear(x)<br>  ​  </p>
<h1 id="创建模型实例-1"><a href="#创建模型实例-1" class="headerlink" title="创建模型实例"></a>创建模型实例</h1><p>  model &#x3D; LinearRegression()  </p>
<h1 id="情况-1：学习率设置为-0-1-较大"><a href="#情况-1：学习率设置为-0-1-较大" class="headerlink" title="情况 1：学习率设置为 0.1 (较大)"></a>情况 1：学习率设置为 0.1 (较大)</h1><p>  optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.1)<br>  ​  </p>
<h1 id="情况-2：学习率设置为-0-01-适中"><a href="#情况-2：学习率设置为-0-01-适中" class="headerlink" title="情况 2：学习率设置为 0.01 (适中)"></a>情况 2：学习率设置为 0.01 (适中)</h1><h1 id="optimizer-optim-SGD-model-parameters-lr-0-01"><a href="#optimizer-optim-SGD-model-parameters-lr-0-01" class="headerlink" title="optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01)"></a>optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01)</h1><p>  ​  </p>
<h1 id="情况-3：学习率设置为-0-001-较小"><a href="#情况-3：学习率设置为-0-001-较小" class="headerlink" title="情况 3：学习率设置为 0.001 (较小)"></a>情况 3：学习率设置为 0.001 (较小)</h1><h1 id="optimizer-optim-SGD-model-parameters-lr-0-001"><a href="#optimizer-optim-SGD-model-parameters-lr-0-001" class="headerlink" title="optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.001)"></a>optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.001)</h1><p>  ​  </p>
<h1 id="…-省略训练循环部分，参考之前的线性回归例子-…"><a href="#…-省略训练循环部分，参考之前的线性回归例子-…" class="headerlink" title="… (省略训练循环部分，参考之前的线性回归例子) …"></a>… (省略训练循环部分，参考之前的线性回归例子) …</h1><ul>
<li><p><strong>情况 1 (lr&#x3D;0.1):</strong> 模型可能会在最小值附近震荡，甚至无法收敛。</p>
</li>
<li><p><strong>情况 2 (lr&#x3D;0.01):</strong> 模型可能会比较平稳地收敛到最小值。</p>
</li>
<li><p><strong>情况 3 (lr&#x3D;0.001):</strong> 模型可能会收敛得很慢，需要更长的训练时间。</p>
</li>
</ul>
</li>
</ul>
<p><strong>二级知识点 8.3：正则化参数 (Regularization Parameter) 🏋️</strong></p>
<ul>
<li><p><strong>范例：</strong> 我们在 PyTorch 中构建一个带有 L2 正则化的线性回归模型。</p>
<p>  import torch<br>  import torch.nn as nn<br>  import torch.optim as optim<br>  ​  </p>
<h1 id="…-省略数据加载和模型定义部分-…"><a href="#…-省略数据加载和模型定义部分-…" class="headerlink" title="… (省略数据加载和模型定义部分) …"></a>… (省略数据加载和模型定义部分) …</h1><h1 id="定义一个简单的线性模型-2"><a href="#定义一个简单的线性模型-2" class="headerlink" title="定义一个简单的线性模型"></a>定义一个简单的线性模型</h1><p>  class LinearRegression(nn.Module):<br>      def <strong>init</strong>(self):<br>          super().<strong>init</strong>()<br>          self.linear &#x3D; nn.Linear(1, 1)  # 输入维度为 1，输出维度为 1<br>  ​<br>      def forward(self, x):<br>          return self.linear(x)<br>  ​  </p>
<h1 id="创建模型实例-2"><a href="#创建模型实例-2" class="headerlink" title="创建模型实例"></a>创建模型实例</h1><p>  model &#x3D; LinearRegression()  </p>
<h1 id="定义优化器，并设置-L2-正则化参数-weight-decay"><a href="#定义优化器，并设置-L2-正则化参数-weight-decay" class="headerlink" title="定义优化器，并设置 L2 正则化参数 (weight_decay)"></a>定义优化器，并设置 L2 正则化参数 (weight_decay)</h1><h1 id="情况-1：正则化参数设置为-0-1-较大"><a href="#情况-1：正则化参数设置为-0-1-较大" class="headerlink" title="情况 1：正则化参数设置为 0.1 (较大)"></a>情况 1：正则化参数设置为 0.1 (较大)</h1><p>  optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01, weight_decay&#x3D;0.1)<br>  ​  </p>
<h1 id="情况-2：正则化参数设置为-0-01-适中"><a href="#情况-2：正则化参数设置为-0-01-适中" class="headerlink" title="情况 2：正则化参数设置为 0.01 (适中)"></a>情况 2：正则化参数设置为 0.01 (适中)</h1><h1 id="optimizer-optim-SGD-model-parameters-lr-0-01-weight-decay-0-01"><a href="#optimizer-optim-SGD-model-parameters-lr-0-01-weight-decay-0-01" class="headerlink" title="optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01, weight_decay&#x3D;0.01)"></a>optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01, weight_decay&#x3D;0.01)</h1><p>  ​  </p>
<h1 id="情况-3：正则化参数设置为-0-无正则化"><a href="#情况-3：正则化参数设置为-0-无正则化" class="headerlink" title="情况 3：正则化参数设置为 0 (无正则化)"></a>情况 3：正则化参数设置为 0 (无正则化)</h1><h1 id="optimizer-optim-SGD-model-parameters-lr-0-01-weight-decay-0"><a href="#optimizer-optim-SGD-model-parameters-lr-0-01-weight-decay-0" class="headerlink" title="optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01, weight_decay&#x3D;0)"></a>optimizer &#x3D; optim.SGD(model.parameters(), lr&#x3D;0.01, weight_decay&#x3D;0)</h1><p>  ​  </p>
<h1 id="…-省略训练循环部分-…"><a href="#…-省略训练循环部分-…" class="headerlink" title="… (省略训练循环部分) …"></a>… (省略训练循环部分) …</h1><ul>
<li><p><strong>情况 1 (weight_decay&#x3D;0.1):</strong> 模型更倾向于选择较小的权重，有助于防止过拟合。</p>
</li>
<li><p><strong>情况 2 (weight_decay&#x3D;0.01):</strong> 正则化的效果适中。</p>
</li>
<li><p><strong>情况 3 (weight_decay&#x3D;0):</strong> 没有正则化，模型可能更容易过拟合。</p>
</li>
</ul>
</li>
</ul>
<p><strong>二级知识点 8.4：神经网络层数 (Number of Layers) 🧱</strong></p>
<ul>
<li><p><strong>范例：</strong> 我们使用 PyTorch 构建不同层数的 MLP。</p>
</li>
<li><p><strong>二级知识点 8.5：批处理大小</strong></p>
</li>
<li><p><strong>二级知识点 8.6： 卷积层参数</strong></p>
</li>
<li><p><strong>二级知识点 8.7： 池化层参数</strong></p>
<p>  import torch<br>  import torch.nn as nn<br>  ​  </p>
<h1 id="情况-1：单层-MLP"><a href="#情况-1：单层-MLP" class="headerlink" title="情况 1：单层 MLP"></a>情况 1：单层 MLP</h1><p>  class MLP1(nn.Module):<br>      def <strong>init</strong>(self, input_size, hidden_size, output_size):<br>          super().<strong>init</strong>()<br>          self.linear &#x3D; nn.Linear(input_size, output_size)<br>  ​<br>      def forward(self, x):<br>          return self.linear(x)<br>  ​  </p>
<h1 id="情况-2：两层-MLP"><a href="#情况-2：两层-MLP" class="headerlink" title="情况 2：两层 MLP"></a>情况 2：两层 MLP</h1><p>  class MLP2(nn.Module):<br>      def <strong>init</strong>(self, input_size, hidden_size, output_size):<br>          super().<strong>init</strong>()<br>          self.linear1 &#x3D; nn.Linear(input_size, hidden_size)<br>          self.relu &#x3D; nn.ReLU()<br>          self.linear2 &#x3D; nn.Linear(hidden_size, output_size)<br>  ​<br>      def forward(self, x):<br>          x &#x3D; self.relu(self.linear1(x))<br>          return self.linear2(x)<br>  ​  </p>
<h1 id="情况-3：三层-MLP"><a href="#情况-3：三层-MLP" class="headerlink" title="情况 3：三层 MLP"></a>情况 3：三层 MLP</h1><p>  class MLP3(nn.Module):<br>      def <strong>init</strong>(self, input_size, hidden_size, output_size):<br>          super().<strong>init</strong>()<br>          self.linear1 &#x3D; nn.Linear(input_size, hidden_size)<br>          self.relu1 &#x3D; nn.ReLU()<br>          self.linear2 &#x3D; nn.Linear(hidden_size, hidden_size)<br>          self.relu2 &#x3D; nn.ReLU()<br>          self.linear3 &#x3D; nn.Linear(hidden_size, output_size)<br>  ​<br>      def forward(self, x):<br>          x &#x3D; self.relu1(self.linear1(x))<br>          x &#x3D; self.relu2(self.linear2(x))<br>          return self.linear3(x)<br>  ​  </p>
<h1 id="情况4：-含有卷积层和池化层的神经网络"><a href="#情况4：-含有卷积层和池化层的神经网络" class="headerlink" title="情况4： 含有卷积层和池化层的神经网络"></a>情况4： 含有卷积层和池化层的神经网络</h1><p>  class CNN(nn.Module):<br>    def <strong>init</strong>(self):<br>        super().<strong>init</strong>()<br>        self.conv1 &#x3D; nn.Conv2d(in_channels&#x3D;3, out_channels&#x3D;16, kernel_size&#x3D;3, stride&#x3D;1, padding&#x3D;1) # 卷积层<br>        self.relu1 &#x3D; nn.ReLU() #激活函数<br>        self.pool1 &#x3D; nn.MaxPool2d(kernel_size&#x3D;2, stride&#x3D;2) #最大池化层<br>        self.conv2 &#x3D; nn.Conv2d(16, 32, 3, 1, 1)<br>        self.relu2 &#x3D; nn.ReLU()<br>        self.pool2 &#x3D; nn.MaxPool2d(2, 2)<br>        self.flatten &#x3D; nn.Flatten()<br>        self.fc &#x3D; nn.Linear(32<em>8</em>8, 10) #全连接层<br>  ​<br>    def forward(self, x):<br>        x &#x3D; self.relu1(self.conv1(x)) # [batch_size, 3, 32, 32] -&gt; [batch_size, 16, 32, 32]<br>        x &#x3D; self.pool1(x) # [batch_size, 16, 32, 32] -&gt; [batch_size, 16, 16, 16]<br>        x &#x3D; self.relu2(self.conv2(x)) # [batch_size, 16, 16, 16] -&gt; [batch_size, 32, 16, 16]<br>        x &#x3D; self.pool2(x) # [batch_size, 32, 16, 16] -&gt; [batch_size, 32, 8, 8]<br>        x &#x3D; self.flatten(x) # [batch_size, 32, 8, 8] -&gt; [batch_size, 32<em>8</em>8]<br>        x &#x3D; self.fc(x) # [batch_size, 32<em>8</em>8] -&gt; [batch_size, 10]<br>        return x</p>
<ul>
<li><p><strong>情况 1 (MLP1):</strong> 模型比较简单，可能无法很好地拟合复杂的数据。</p>
</li>
<li><p><strong>情况 2 (MLP2):</strong> 模型的表示能力有所增强。</p>
</li>
<li><p><strong>情况 3 (MLP3):</strong> 模型的表示能力更强，但也更容易过拟合。</p>
</li>
<li><p><strong>情况4：</strong></p>
<ul>
<li><p>卷积核大小为 3x3， 步长为1， 填充为1</p>
</li>
<li><p>池化核大小为 2x2, 步长为2</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>二级知识点 8.8：迭代周期 (Epochs) 🔁</strong></p>
<p>假设其他参数不变的情况下， 神经网络训练5个周期和500个周期，最终模型的效果可能会有显著差别。</p>
<p>这些范例展示了不同超参数对模型的影响。在实际应用中，你需要根据具体的任务、数据集和硬件条件，通过实验来确定最佳的超参数组合。通常会使用网格搜索、随机搜索或贝叶斯优化等方法来进行超参数调优。</p>
<hr>
<p>为了让疯🉐更全面，我将为你提供一个综合性的代码示例，涵盖以下内容：</p>
<p>注意：⚠️ 这只是一个很简单 ⚠️ 的一个架构示例代码</p>
<ol>
<li><p><strong>构建一个简单的多层感知器 (MLP) 模型 (PyTorch)</strong></p>
</li>
<li><p><strong>使用模拟数据进行训练</strong></p>
</li>
<li><p><strong>展示前向传播、反向传播、损失函数计算和优化器更新的过程</strong></p>
</li>
<li><p><strong>包含对关键步骤的注释</strong></p>
</li>
</ol>
<p>import torch<br>import torch.nn as nn<br>import torch.optim as optim<br>​  </p>
<h1 id="1-定义-MLP-模型"><a href="#1-定义-MLP-模型" class="headerlink" title="1. 定义 MLP 模型"></a>1. 定义 MLP 模型</h1><p>class MLP(nn.Module):<br>    def <strong>init</strong>(self, input_size, hidden_size, output_size):<br>        super(MLP, self).<strong>init</strong>()<br>        self.fc1 &#x3D; nn.Linear(input_size, hidden_size)  # 全连接层 1<br>        self.relu &#x3D; nn.ReLU()  # ReLU 激活函数<br>        self.fc2 &#x3D; nn.Linear(hidden_size, output_size)  # 全连接层 2<br>​<br>    def forward(self, x):<br>        out &#x3D; self.fc1(x)  # 第一层<br>        out &#x3D; self.relu(out)  # ReLU 激活<br>        out &#x3D; self.fc2(out)  # 第二层<br>        return out<br>​  </p>
<h1 id="2-准备数据-模拟数据"><a href="#2-准备数据-模拟数据" class="headerlink" title="2. 准备数据 (模拟数据)"></a>2. 准备数据 (模拟数据)</h1><p>input_size &#x3D; 10<br>output_size &#x3D; 2<br>batch_size &#x3D; 32<br>​  </p>
<h1 id="生成随机输入数据-模拟-100-个样本"><a href="#生成随机输入数据-模拟-100-个样本" class="headerlink" title="生成随机输入数据 (模拟 100 个样本)"></a>生成随机输入数据 (模拟 100 个样本)</h1><p>x &#x3D; torch.randn(100, input_size)  </p>
<h1 id="生成随机标签-二分类问题，0-或-1"><a href="#生成随机标签-二分类问题，0-或-1" class="headerlink" title="生成随机标签 (二分类问题，0 或 1)"></a>生成随机标签 (二分类问题，0 或 1)</h1><p>y &#x3D; torch.randint(0, 2, (100,)).long() #需要时long 类型<br>​  </p>
<h1 id="3-定义模型、损失函数和优化器"><a href="#3-定义模型、损失函数和优化器" class="headerlink" title="3. 定义模型、损失函数和优化器"></a>3. 定义模型、损失函数和优化器</h1><p>hidden_size &#x3D; 64<br>model &#x3D; MLP(input_size, hidden_size, output_size)<br>criterion &#x3D; nn.CrossEntropyLoss()  # 交叉熵损失函数 (适用于多分类问题)<br>optimizer &#x3D; optim.Adam(model.parameters(), lr&#x3D;0.001)  # Adam 优化器<br>​  </p>
<h1 id="4-训练模型"><a href="#4-训练模型" class="headerlink" title="4. 训练模型"></a>4. 训练模型</h1><p>epochs &#x3D; 100<br>for epoch in range(epochs):<br>    # 将数据分成批次<br>    for i in range(0, 100, batch_size):<br>        # 获取当前批次的输入和标签<br>        x_batch &#x3D; x[i:i+batch_size]<br>        y_batch &#x3D; y[i:i+batch_size]<br>​<br>        # 前向传播<br>        outputs &#x3D; model(x_batch)<br>​<br>        # 计算损失<br>        loss &#x3D; criterion(outputs, y_batch)<br>​<br>        # 反向传播 (计算梯度)<br>        loss.backward()<br>​<br>        # 更新参数 (使用优化器)<br>        optimizer.step()<br>​<br>        # 清空梯度 (重要！)<br>        optimizer.zero_grad()<br>​<br>    # 打印每个 epoch 的损失<br>    if (epoch+1) % 10 &#x3D;&#x3D; 0:<br>        print(f’Epoch [{epoch+1}&#x2F;{epochs}], Loss: {loss.item():.4f}’)<br>​<br>print(‘训练完成!’)<br>​  </p>
<h1 id="5-可选-在测试集上评估模型"><a href="#5-可选-在测试集上评估模型" class="headerlink" title="5. (可选) 在测试集上评估模型"></a>5. (可选) 在测试集上评估模型</h1><h1 id="…-这里省略了测试集的代码，你需要准备一个测试集并进行类似的前向传播和损失计算-…"><a href="#…-这里省略了测试集的代码，你需要准备一个测试集并进行类似的前向传播和损失计算-…" class="headerlink" title="… (这里省略了测试集的代码，你需要准备一个测试集并进行类似的前向传播和损失计算) …"></a>… (这里省略了测试集的代码，你需要准备一个测试集并进行类似的前向传播和损失计算) …</h1><p><strong>代码解释:</strong></p>
<ul>
<li><p><strong>模型定义 (MLP 类):</strong></p>
<ul>
<li><p><code>__init__</code>: 定义了模型的结构，包括两个全连接层 (fc1 和 fc2) 和一个 ReLU 激活函数。</p>
</li>
<li><p><code>forward</code>: 定义了前向传播的过程，数据依次经过 fc1、ReLU 和 fc2。</p>
</li>
</ul>
</li>
<li><p><strong>数据准备:</strong></p>
<ul>
<li><p><code>x</code>: 模拟的输入数据，形状为 (100, 10)，表示 100 个样本，每个样本有 10 个特征。</p>
</li>
<li><p><code>y</code>: 模拟的标签，形状为 (100,)，表示 100 个样本的类别标签 (0 或 1)。</p>
</li>
</ul>
</li>
<li><p><strong>模型、损失函数和优化器:</strong></p>
<ul>
<li><p><code>model</code>: 创建 MLP 模型实例。</p>
</li>
<li><p><code>criterion</code>: 使用交叉熵损失函数 (CrossEntropyLoss)，适用于多分类问题（这里我们是二分类，但 CrossEntropyLoss 也可以用）。</p>
</li>
<li><p><code>optimizer</code>: 使用 Adam 优化器，并传入模型的参数和学习率。</p>
</li>
</ul>
</li>
<li><p><strong>训练循环:</strong></p>
<ul>
<li><p><code>epochs</code>: 训练的轮数。</p>
</li>
<li><p><strong>批次划分:</strong> 将数据分成多个批次，每次迭代只使用一个批次的数据。</p>
</li>
<li><p><strong>前向传播:</strong> <code>outputs = model(x_batch)</code>，将输入数据传入模型，得到输出。</p>
</li>
<li><p><strong>计算损失:</strong> <code>loss = criterion(outputs, y_batch)</code>，计算模型输出与真实标签之间的损失。</p>
</li>
<li><p><strong>反向传播:</strong> <code>loss.backward()</code>，自动计算损失函数相对于模型参数的梯度。</p>
</li>
<li><p><strong>更新参数:</strong> <code>optimizer.step()</code>，使用优化器根据梯度更新模型的参数。</p>
</li>
<li><p><strong>清空梯度:</strong> <code>optimizer.zero_grad()</code>，在每次更新参数后，需要清空梯度，否则梯度会累积。</p>
</li>
</ul>
</li>
<li><p><strong>代码涵盖了所有之前的知识点范例</strong></p>
</li>
</ul>
<p>这个代码示例展示了一个完整的神经网络训练流程，包括模型定义、数据准备、前向传播、反向传播、损失函数计算和优化器更新。你可以运行这段代码，观察模型的训练过程和损失的变化。</p>
<p>请注意，这只是一个非常基础的示例。在实际应用中，你可能需要处理更复杂的数据集、构建更复杂的模型、调整更多的超参数，并使用更高级的技术来提高模型的性能。</p>
<p>恭喜你！你已经完成了所有知识点的学习！🎉🎉🎉 你现在对神经网络、反向传播算法以及相关的概念有了更深入的了解。也正式开始风（疯）口浪尖般的生活了。如果你有任何问题，或者想进一步探索某个方面，请随时告诉我！😊</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>AI自动化爬虫项目对比报告</p><p><a href="http://acorner.ac.cn/2025/02/25/一篇“**神经网络中的反向传播**”引发的学习血案/">http://acorner.ac.cn/2025/02/25/一篇“**神经网络中的反向传播**”引发的学习血案/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ViniJack.SJX</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-02-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-02-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/AI/">AI</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%88%AC%E8%99%AB/">爬虫</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://github.com/A-Corner/a-corner.github.io" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/02/21/Michael%20Luo%20....%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/"><span class="level-item">关于“DeepScaleR：通过扩展强化学习，用1.5B模型超越O1-Preview”（译文）阅读报告</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="A-Corner"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">A-Corner</p><p class="is-size-6 is-block">信息的一角</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China（Guangzhou）</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">19</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/A-Corner/a-corner.github.io" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/A-Corner/a-corner.github.io"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/LLM/"><span class="level-start"><span class="level-item">LLM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Model/"><span class="level-start"><span class="level-item">Model</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/RAG/"><span class="level-start"><span class="level-item">RAG</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"><span class="level-start"><span class="level-item">分析报告</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">原理</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">向量数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">强化学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BE%AE%E8%B0%83/"><span class="level-start"><span class="level-item">微调</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%A1%86%E6%9E%B6/"><span class="level-start"><span class="level-item">框架</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/"><span class="level-start"><span class="level-item">阅读报告</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A3%9F%E7%94%A8%E6%96%87%E6%A1%A3/"><span class="level-start"><span class="level-item">食用文档</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-25T03:20:54.429Z">2025-02-25</time></p><p class="title"><a href="/2025/02/25/%E4%B8%80%E7%AF%87%E2%80%9C**%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD**%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A1%80%E6%A1%88/">AI自动化爬虫项目对比报告</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/">分析报告</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-21T03:26:59.380Z">2025-02-21</time></p><p class="title"><a href="/2025/02/21/Michael%20Luo%20....%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/">关于“DeepScaleR：通过扩展强化学习，用1.5B模型超越O1-Preview”（译文）阅读报告</a></p><p class="categories"><a href="/categories/LLM/">LLM</a> / <a href="/categories/%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/">分析报告</a> / <a href="/categories/%E5%8E%9F%E7%90%86/">原理</a> / <a href="/categories/%E5%BE%AE%E8%B0%83/">微调</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">强化学习</a> / <a href="/categories/%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/">阅读报告</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-20T06:44:10.490Z">2025-02-20</time></p><p class="title"><a href="/2025/02/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">深度学习数学基础入门</a></p><p class="categories"><a href="/categories/LLM/">LLM</a> / <a href="/categories/%E5%8E%9F%E7%90%86/">原理</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-18T15:22:21.629Z">2025-02-18</time></p><p class="title"><a href="/2025/02/18/llm_gradient_descent/">大语言模型中的梯度值：深入理解与应用</a></p><p class="categories"><a href="/categories/LLM/">LLM</a> / <a href="/categories/%E5%8E%9F%E7%90%86/">原理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-18T09:06:39.943Z">2025-02-18</time></p><p class="title"><a href="/2025/02/18/Embed%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/">Embedding 模型入门级研究报告</a></p><p class="categories"><a href="/categories/LLM/">LLM</a> / <a href="/categories/%E5%8E%9F%E7%90%86/">原理</a> / <a href="/categories/Model/">Model</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLM/"><span class="tag">LLM</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Model/"><span class="tag">Model</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAG/"><span class="tag">RAG</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%A5%E9%97%A8/"><span class="tag">入门</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"><span class="tag">分析报告</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E7%90%86/"><span class="tag">原理</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">向量数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"><span class="tag">强化学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E8%B0%83/"><span class="tag">微调</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A6%82%E7%8E%87/"><span class="tag">概率</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"><span class="tag">自动化</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/"><span class="tag">阅读报告</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A3%9F%E7%94%A8%E6%96%87%E6%A1%A3/"><span class="tag">食用文档</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/%E4%B8%80%E8%A7%92logo.png" alt="A-Acorner 信息的一角" height="28"></a><p class="is-size-7"><span>&copy; 2025 ViniJack.SJX</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2025 A-Corner</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/A-Corner/a-corner.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>